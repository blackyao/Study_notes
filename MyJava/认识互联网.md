全栈学习---遇见狂神说

# 阶段一：JAVA SE基础学习

## 基础

### 标识符/关键字

![image-20200410102134334](https://i.loli.net/2020/04/28/BbqpL8UDS5MVcmZ.png)

### 数据类型

* 类型转换
  * 小转大正常写
  * 大转小 强制转换
* 四类八种

```javascript
byte short int long //整数类型
float double //小数
boolean  //布尔
char // 字符
```

### 基本运算符

![image-20200410102112944](https://i.loli.net/2020/04/28/rp9hnzvb7ufo5Yg.png)

### 包机制

![image-20200410101821177](https://i.loli.net/2020/04/28/z7uovc9q2JOwpU3.png)

### 流程控制

```java
if/else
while
do while
for
switch id
    case '1':
		break;
continue
```

## 方法

### 定义

![image-20200410102657202](https://i.loli.net/2020/04/28/Wye7hrogOEVYFi1.png)

### 方法调用

* 静态
* 非静态
* 形参和实参
* 值传递/引用传递
* this关键字

### 方法重载

方法名相同，参数列表（**个数/类型/顺序**）必须不同，调用方法时JVN自动判断

### 可变参数

* 可变参数必须放在普通参数后面

```java
public class Demo02 {
    public static void main(String[] args) {
        test(1,2,3,4,5,6);
    }

    public static void test(int ...i){
        System.out.println(i[0]);
        System.out.println(i[1]);
        System.out.println(i[2]);
    }
}
```

### 递归

## 数组

### 初始化

```java
//静态初始化：创建+赋值
int[] a = {1,2,3,4,5,6,7,8};

//动态初始化：创建并默认初始化
int[] a = new int[10];
```

### 数组在内存中

* 声明数组是在栈中
* 创建数组/赋值 在堆中

![image-20200410113325177](https://i.loli.net/2020/04/28/SPvmFBpOClXcRDV.png)

### 多维数组

![image-20200410142533473](https://i.loli.net/2020/04/28/sP8pQfNrVobztLv.png)

```java
//数组类
import java.util.Arrays
```

### *稀疏数组？

## 面向对象（OOP）

**本质：以类的方式组织代码，以对象的组织（封装）数据**

抽象思维

三大特性：

* 封装
* 继承
* 多态

对象，是具体的事物。类，是抽象的，是对对象的抽象

### 创建对象

```java
package com.f4ke.oop;

// 一个主项目应该只有一个main方法
public class Application {
    public static void main(String[] args) {
        Student f4ke = new Student();
        f4ke.name = "f4ke";
        f4ke.study();

    }
}
```

```java
package com.f4ke.oop;

//学生类
public class Student {
    String name;
    int age;

    public void study(){
        System.out.println(this.name + "在学习！");
    }
}
```

### 构造器

```java
public class Application {
    public static void main(String[] args) {

        //实例化student对象
        Student student = new Student("f4ke");

        System.out.println(student.name);
    }
}
```

```java
/*
构造器：
	1. 和类名相同
	2. 没有返回值
作用：
	1. 使用new关键字，本质为调用构造器
	2. 初始化对象的值
	3. 一旦定义了有参构造，无参构造必须显式定义
快捷键：
Alt+Insert IDEA快捷创建一个构造器
*/
//学生类
public class Student {

    String name;

    //初始化一个新建的实例
    //显式定义  无参构造
    public Student(){

    }
    //有参构造
    //一旦定义了有参构造，无参构造必须显式定义
    public Student(String name){
        this.name = name;
    }

}
```

### 内存简化图

类是一个模板，是抽象的

* 属性  静态的属性
* 方法  动态的方法

对象是一个具体的实例

![image-20200413145515084](https://i.loli.net/2020/04/28/St24z6KXEZgyHdj.png)

### 封装

**"高内聚，低耦合"原则**

1. 防止对属性直接操作，增强安全性
2. 统一接口

```java
private String name;

Alt+Insert IDEA快捷创建一个get/set方法
```

### 继承

继承是类和类直接的关系

```bash
-- 在java中，所有类，都直接或间接继承Object类
```

![image-20200413170229648](https://i.loli.net/2020/04/28/5Ze8LIsx4GNSjuM.png)

子类会继承父类的全部方法

![image-20200413170947891](https://i.loli.net/2020/04/28/vMXUiQNqhs8c4IL.png)

```java
//封装/继承结合

// Ctrl + H  查看继承树

public class Person {

    private int money;

    public int getMoney() {
        return money;
    }

    public void setMoney(int money) {
        this.money = money;
    }

    public void say(){
        System.out.println("233333");
    }

}
```

#### super

```ini
super 注意点：
	1. super调用父类的构造方法，必须在构造方法的第一个
	2. super必须只能出现在子类的方法或者构造方法中
	3. super 和 this 不能同时调用构造方法
	
this:
	对象不同
	this: 本身调用者这个对象
	super: 代表父类对象的引用
	前提
		this 没有继承也能使用
		super 继承条件下才可以使用
		
	构造方法
		this 本类构造
		super 父类构造
```

#### 方法重写

重写是方法的重写，与属性无关

```ini
- 重写: 需要由继承关系，子类重写父类的方法
	1. 方法名必须相同
	2. 参数列表必须相同
	3. 修饰符：范围可以扩大  public > protected > default > private
	4. 抛出的异常：范围，可以被缩小，不能被扩大
```

### 多态

```ini
- 多态注意事项
	1. 多态是方法的多态，属性没有
	2. 要有联系，如父类和子类，否则类型转换异常
	3. 多态存在条件：
		继承关系
		方法需要重写
		父类引用指向子类对象
		
static,final,private方法不可重写
```

### static

![image-20200414120107901](https://i.loli.net/2020/04/28/SN5UadDHQzvG7rW.png)

### 抽象类

1. 不能new，只能靠子类去实现
2. 抽象类中可以写普通方法，抽象方法必须在抽象类中



## 接口

### 接口的定义和实现

接口的本质是契约

```ini
接口的作用：
	1. 约束
	2. 定义一些方法，让不同的人实现
	2. pubilc abstract
	4. public static final 
	5. 接口不能被实例化，接口中没有构造方法
	6. implements 可以实现多个接口
	7. 必须重写接口中的方法
```

两个接口

```java
package com.f4ke.oop.demo04;

public interface TimeService {
    void add();
    void update();
    void query();
}
```

```java
//interface关键字定义，接口都需要实现类
public interface UserService {
    //接口中的所有定义都是抽象的  public abstract
    public abstract void run();

    //默认 public static final
    public static final int age = 77;

}
```

```java
//类实现接口  implements
//实现了接口的类，就需要重写接口中的方法

public class UserServiceImpl implements UserService,TimeService {

    @Override
    public void run() {

    }

    @Override
    public void add() {

    }

    @Override
    public void update() {

    }

    @Override
    public void query() {

    }
}
```

## 内部类

内部类，外部类，局部内部类。。

多线程，JVM中详解

## 异常

> IDEA异常快捷键  Ctrl + Alt + T

![image-20200414144518717](https://i.loli.net/2020/04/28/4G6InyvjSd8eEXo.png)

## 注解 （Annotation）

 **可以被其他程序（比如编译器）读取**

注解作用：通过反射机制来使用注解

```ini
注解语法： @xxxx
    
内置注解：
    @Override 重写方法
    @Deprecated 废弃
    @SuppressWarnings 抑制编译时的警告信息
    

元注解： 注解其他注解
    @Target  表示注解可以用在什么地方
    @Retention  表示注解在什么地方有效  runtime>class>sources
    @Documented 表示是否将我们的注解生成在javadoc中
    @Inherited  子类可以继承父类中的该注解
  
自定义注解：
    @interface
    
```

```java
/*内置注解：
    @Override 重写方法
    @Deprecated 废弃
    @SuppressWarnings 抑制编译时的警告信息
*/
@Override
public String toString(){
    return super.toString();
}

@Deprecated
public static void test() {
    System.out.println("Deprecated!");
}

public static void main(String[] args) {
    test();
}

@SuppressWarnings("all")
```



## 反射机制（reflection）

![image-20200507161402942](https://i.loli.net/2020/05/07/gYUK4G5w61xbEfM.png)

![image-20200507164311467](https://i.loli.net/2020/05/07/cPZAegaNL9EoHiy.png)

### 类的主动引用：

```java
package com.f4ke.annotation;

public class Test02 {
    static {
        System.out.println("main被加载");
    }

    public static void main(String[] args) throws ClassNotFoundException {
        //主动引用
        //Son son = new Son();

        //反射也会产生主动引用
        Class.forName("com.f4ke.annotation.Son");

    }
}

class Father{
    static {
        System.out.println("父类被加载");
    }
    static int m = 5;
}

class Son extends Father{
    static {
        System.out.println("子类被加载");
        m = 50;
    }
    static final int M = 1;
}
```

![image-20200507164335378](https://i.loli.net/2020/05/07/CBLolHNPMmZbXwJ.png)

类的被动引用：

```java
//不会产生类的引用的方法
System.out.println(Son.b);
/*
main被加载
父类被加载
5
*/

Son[] array = new Son[5];
/*
main被加载
*/

System.out.println(Son.M);
/*
main被加载
1
*/
```

### 反射的实现

```java
package com.f4ke.reflection;

//什么叫反射
public class Test02 {
    public static void main(String[] args) throws ClassNotFoundException {
        //通过反射获取类的Class对象
        Class c1 = Class.forName("com.f4ke.reflection.User");
        System.out.println(c1);
        
        //一个类在内存中只有一个Class对象
        //一个类被加载后，类的整个结构都会封装在Class对象中
    }

}

class User{
    private String name;
    private int id;
    private int age;

    public User() {
    }

    public User(String name, int id, int age) {
        this.name = name;
        this.id = id;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getId() {
        return id;
    }

    public int getAge() {
        return age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", id=" + id +
                ", age=" + age +
                '}';
    }
}

/*
output:
class com.f4ke.reflection.User
*/
```

### 类加载器

![image-20200507171723664](https://i.loli.net/2020/05/07/lsZcTYqLwbjRQUv.png)



```java
package com.f4ke.reflection;


public class Test01 {
    public static void main(String[] args) throws ClassNotFoundException {
        //获取系统类的加载器
        ClassLoader systemClassloader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassloader);

        //获取系统类加载器的父类加载器 --> 扩展类加载器
        ClassLoader parent = systemClassloader.getParent();
        System.out.println(parent);

        //获取扩展类加载器的父类加载器 --> 根加载器
        ClassLoader parentofparent = parent.getParent();
        System.out.println(parentofparent);

        //获取当前类是哪个类加载器加载的
        ClassLoader classLoader = Class.forName("com.f4ke.reflection.Test01").getClassLoader();
        System.out.println(classLoader);

        //测试JDK内置的类是谁加载的
        classLoader = Class.forName("java.lang.Object").getClassLoader();
        System.out.println(classLoader);
    }
}


output:
/*
jdk.internal.loader.ClassLoaders$AppClassLoader@78308db1
jdk.internal.loader.ClassLoaders$PlatformClassLoader@5fd0d5ae
null
jdk.internal.loader.ClassLoaders$AppClassLoader@78308db1
null
*/
```

### 创建运行时类的对象，获得类的信息（属性和方法）

```java
package com.f4ke.reflection;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

//获得类的信息
public class Test03 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException {
        Class c1 = Class.forName("com.f4ke.reflection.User");

        //User user = new User();
        //c1 = user.getClass();
        //获得类的名字
        System.out.println(c1.getName()); //获得类名+包名
        System.out.println(c1.getSimpleName()); //获得类名

        //获得类的属性
        System.out.println("==========================");
//        Field[] fields = c1.getFields(); 只能找到public属性
//        for (Field field : fields) {
//            System.out.println(field);
//        }
        Field[] declaredFields = c1.getDeclaredFields(); //可以列出全部属性
        for (Field declaredField : declaredFields) {
            System.out.println(declaredField);
        }

        //获得类的指定属性
        System.out.println("==========================");
        Field declaredField = c1.getDeclaredField("name");
        System.out.println(declaredField);

        //获得类的方法
            //获得本类及其父类的全部public方法
        System.out.println("==========================");
        Method[] methods = c1.getMethods();
        for (Method method : methods) {
            System.out.println(method);
        }
            //获得本类的所有方法
        System.out.println("==========================");
        Method[] declaredMethods = c1.getDeclaredMethods();
        for (Method declaredMethod : declaredMethods) {
            System.out.println("getDeclaredMethods:"+declaredMethod);
        }

        //获得指定方法
        System.out.println("==========================");
        Method getName = c1.getMethod("getName",null);
        Method setName = c1.getMethod("setName", String.class);
        System.out.println(getName);

        //获得指定的构造器
        System.out.println("==========================");
        Constructor[] constructors = c1.getConstructors();
        for (Constructor constructor : constructors) {
            System.out.println(constructor);
        }

    }
}
```

```java
output:
com.f4ke.reflection.User
User
==========================
private java.lang.String com.f4ke.reflection.User.name
private int com.f4ke.reflection.User.id
private int com.f4ke.reflection.User.age
==========================
private java.lang.String com.f4ke.reflection.User.name
==========================
public java.lang.String com.f4ke.reflection.User.toString()
public java.lang.String com.f4ke.reflection.User.getName()
public void com.f4ke.reflection.User.setName(java.lang.String)
public int com.f4ke.reflection.User.getId()
public int com.f4ke.reflection.User.getAge()
public void com.f4ke.reflection.User.setId(int)
public void com.f4ke.reflection.User.setAge(int)
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
==========================
getDeclaredMethods:public java.lang.String com.f4ke.reflection.User.toString()
getDeclaredMethods:public java.lang.String com.f4ke.reflection.User.getName()
getDeclaredMethods:public void com.f4ke.reflection.User.setName(java.lang.String)
getDeclaredMethods:public int com.f4ke.reflection.User.getId()
getDeclaredMethods:public int com.f4ke.reflection.User.getAge()
getDeclaredMethods:public void com.f4ke.reflection.User.setId(int)
getDeclaredMethods:public void com.f4ke.reflection.User.setAge(int)
==========================
public java.lang.String com.f4ke.reflection.User.getName()
==========================
public com.f4ke.reflection.User()
public com.f4ke.reflection.User(java.lang.String,int,int)
```

### 动态创建对象，执行方法与属性

```java
package com.f4ke.reflection;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

//动态的创建对象 ， 通过反射
public class Test04 {
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {
        //获得Class对象
        Class c1 = Class.forName("com.f4ke.reflection.User");

        //通过构造器创建对象
            //本质上是调用了类的无参构造器
        User user = (User) c1.getDeclaredConstructor(String.class,int.class,int.class).newInstance("f4ke",1,19);
        System.out.println(user);

        //创建user2对象
        User user2 = (User) c1.getDeclaredConstructor().newInstance();

        //通过反射获取方法
        Method setName = c1.getDeclaredMethod("setName", String.class);
        setName.invoke(user2,"f4ke");
        System.out.println(user2.getName());

        //通过反射操作属性
        System.out.println("=====================");
        User user3 = (User) c1.getDeclaredConstructor().newInstance();
        Field name = c1.getDeclaredField("name");

        //不能直接操作私有属性，需要关闭程序的安全检测
        name.setAccessible(true); //关闭程序的安全检测
        name.set(user3,"yulin");
        System.out.println(user3.getName());
    }
}
```

```java
User{name='f4ke', id=1, age=19}
f4ke
=====================
yulin
```





## JVM

# 阶段二：前端

## HTML

HTML5+CSS3

### 基础标签

```html
//注释快捷键
ctrl+/
//描述性标签，一般用来SEO
<meta name="keywords" content="F4ke">
//标题标签
<h1></h1>
//段落标签
<p></p>
//水平线标签
<hr/>
//换行标签
<br/>
//特殊符号
&nbsp; 空格
&gt;
&lt;
&copy;
<!--
&   ; 
-->
```

### 超链接标签

```html
<!--
href必填，表示要跳转到哪个页面
target 表示窗口在哪里打开
# 锚链接 使用name做标记
mailto: 邮件链接
-->
<a href="//src#top"></a>
<a href="mailto:12345789@qq.com"></a>
```

块元素/行内元素

### 列表标签

```html
//有序列表
<ol>
    <li></li>
</ol>
//无表
<ul></ul>
<!--
自定义列表
dl 标签
dt 列表名称
dd 列表内容
-->
<dl>
    <dt></dt>
    <dd></dd>
</dl>
```

### 表格标签

```html
<table>
    <tr>//行
        <!-- colspan 跨列 -->
        <td colspan="3">列</td>
    </tr>
</table>
```

### 页面结构

```HTML
<header></header>
<footer></footer>
<nav>导航类</nav>
<section>web页面中独立区域</section>
```

### iframe内联框架

```html
//src 引用页面地址
//name 框架标识名
<iframe>
    src="" name="" 
</iframe>
```

### 表单

```html
<!--
action 表单提交的位置，可以是网站，也可以是请求处理地址
所有input标签都要带name属性
-->
<form method="" action="">
    <p>用户名：<input type="" name=""></p>
    <p>密码：<input type="" name=""></p>
</form> 

<p>注册</p>
<form action="" method="get">
    <p>用户名：<input type="text" name="user"/></p>
    <p>密码  ：<input type="password" name="passwd"/></p>
    <p>
        <!-- radio 单选框-->
        <!-- value 单选框的值  name 一个组  -->
        <input type="radio" value="boy" name="sex"/>男
        <input type="radio" value="girl" name="sex">女
    </p>
    <p>
        <!-- checkbox 多选框  -->
        <input type="checkbox" value="sleep" name="like" checked/>睡觉
        <input type="checkbox" value="chat" name="like"/>聊天
    </p>

    <p>按钮：
        <input type="button" name="bt1" value=""/>
        <input type="image" src=""/>
    </p>
    <p>
        <!-- 提交表单  -->
        <input type="submit"/>
        <input type="reset" value="清空表单"/>
    </p>
    
    <p>下拉框：
        <select name="列表名称" id="">
            <option value="CN">中国</option>
            <option value="HK" selected>中国香港</option>
        </select>
        
    </p>
    
    <p>文本域：
        <textarea name="textarea" id="" cols="30" rows="10"></textarea>
    </p>

    <p>文件域:
        <input type="file" name="files">
        <input type="button" value="上传" name="upload">
    </p>

    <!-- 邮箱   -->
    <p>email
        <input type="email" name="emails">
    </p>
</form>
```

### 表单应用和初级验证

```html
hidden 隐藏
readonly 只读
disabled 禁用表单

<!-- 
placeholder="请输入用户名" 
required 非空
pattern="^[0-9]*$"
-->
<form action="" method="get">
    <p>用户名：<input type="text" name="user" placeholder="请输入用户名" required pattern="^[0-9]*$"/></p>
    
</form>
```

## XML

### 概述

Extensible Markup Language  可扩展标记语言

```ini
功能：
	配置文件
	在网络中传输
```

```xml
<?xml version='1.0' ?>
//encoding：编码方式 默认：ISO-8859-1
//standalone:是否独立,是否依赖其他文件
<!-- 语法严格 -->
<users>
    <user id = "1">
        <name>f4k4</name>
        <age>23</age>
    </user> 
</users>
```

### 约束文档

规定XML文档的书写规则

![image-20200414163430649](https://i.loli.net/2020/04/28/RdIK8SHN6eWfLbY.png)

#### DTD(document type definition)文档

* 内部DTD：将约束规则定义在xml文档中

* 外部DTD：将约束的规则定义在外部的dtd文件中    <!-- XXE漏洞 -->

  * 本地

  ```dtd
  <!DOCTYPE 根标签名 SYSTEM "dtd文件位置">
  ```

  * 网络

  ```dtd
  <!DOCTYPE 根标签名 PUBILC "dtd文件名字" "dtd文件位置URL">
  ```



#### schema文档 (了解)



### 解析

操作XML文档，将文档中的数据读取到内存中

方式：	

 1. DOM ：一次性读取加载进内存，在内存中形成DOM树  （多用于服务器端）

    ```ini
    优点：操作方便，CRUD操作
    缺点：占内存
    ```

 2. SAX ： 逐行读取，基于事件驱动  （用于移动端）

    ```ini
    优点：不占内存
    缺点：只能读，不能增删改
    ```

#### 常见的解析器

jsoup : java的HTML解析器

PULL ： 安卓系统内置的解析器，sax方式

DOM4J

#### JSOUP

## CSS

### 选择器规范

```css
    <!--规范 , <style> 编写CSS代码
     语法：
        选择器 {
            声明1;
            声明2;
            声明3;

        }

     -->
    <style>
        h1{
            color: blue;
        }
    </style>
<body>
    <h1>
        我是标题
    </h1>
</body>
```

内容表现分离

![image-20200331153539236](https://i.loli.net/2020/04/28/kuBn8tUTPNbg9cd.png)

优势：

* 内容表现分离
* 网页结构表现统一，可复用
* 样式丰富
* 建议使用独立于HTML的css文件
* 利于SEO，容易被搜索引擎收录

### 引入方式

* 优先级：行内样式 > 内部/外部样式

```css
    <!-- 内部样式   -->
	<style>
        h1 {
            color: crimson;
        }
    </style>
    <!-- 外部样式   -->
    <link rel="stylesheet" href="css/style.css">
</head>

<body>
    <!--行内样式 标签元素内style属性    -->
    <h1 style="color: cornflowerblue">我是标题</h1>
</body>
```

### 基本选择器

* 标签选择器  **标签名**
* 类 class 选择器  **.class**
* id 选择器  **#id**
* 优先级： id > class > 标签

```html
    <style>
        h1{
            color: darkgoldenrod;
        }
        .hello{
            color: rgba(169, 45, 28, 0.62);
        }
        .word{
            color: chartreuse;
        }
        #dell{
            color: blue;
        }
    </style>
</head>

<body>
    <!--行内样式 标签元素内style属性    -->
    <h1>我是标题1</h1>
    <h1 class="hello">我是标题2</h1>
    <h1 class="word">我是标题3</h1>
    <h1 id="dell">我是标题4</h1>
</body>
```

### 层级选择器/结构伪类选择器

### 属性选择器



## JavaScript

### 历史

[JavaScript的起源故事](https://blog.csdn.net/kese7952/article/details/79357868)

### jQuery选择器

>  jQuery

```javascript
//原生js
//id选择器
document.getElementById();
//标签选择器
document.getElementsByTagName();
//类选择器
document.getElementsByClassName();

//jQuery
$('a').click(); //标签选择器
$('#id1').click(); //id选择器
$('.class1').click();//类选择器

//公式：$(selector).action()
```

* [jQuery中文文档](http://jquery.cuishifeng.cn/)

<!--Shift+Tab 代码缩进-->

> 操作DOM

```html
<ui id="test-ul">
    <li class="js">JavaScript</li>
    <li name="python">python</li>
</ui>

<script>
    $('#test-ul li[name=python]').text(); //获得值
    $('#test-ul li[name=python]').text(''); //设置值
</script>
```



> 小技巧

* 巩固js : 看jQuery源码，看游戏源码
* 巩固html/css ：扒网站，对应修改看效果



## Node

## jsonp/CORS

## VUE

## 安服前端面试

* [各种跨域方法的描述](https://juejin.im/post/5c23993de51d457b8c1f4ee1)---9种

* [浏览器LocalStorage与SessionStorage的区别](http://yulige.top/?p=685#LocalStorageSessionStorage)

  | localStorage             | sessionStorage                               |
  | ------------------------ | -------------------------------------------- |
  | 除非被清除，否则永久保存 | 仅在当前会话下有效，关闭页面或浏览器后被清除 |

* 如何绕过httponly

  * 钓鱼 [XSS 之 httponly 绕过](https://www.mrwu.red/biji/3047.html)
  * HTML5 CORS特性  [利用HTML5的CORS特性绕过HttpOnly的限制实现XSS会话劫持](http://www.tiejiang.org/16840.html)

# 阶段三：数据库

## 数据库分类

关系型数据库：SQL

* MySQL，Oracle，Sql Server，DB2，SQLite
* 通过表和表/列和列关系进行数据的存储

非关系型数据库：NoSQL  （Not Only SQL）

* Redis，MongoDB
* 对象存储，通过对象自身的属性来决定

## MySQL数据库

Oracle旗下产品/最好的RDBMS应用软件之一

企业多数使用版本：

* 5.7 稳定 
* 8.0

### **DBMS(数据库管理系统)**

* 数据库的管理软件，管理维护数据
* MySQL,数据库管理系统

### 安装配置

1. my.ini

```ini
[mysqld]
basedir=E:\Java\mysql-5.7
datadir=E:\Java\mysql-5.7\data
port=3306
skip-grant-tables
```

2. 初始化mysqld

```bash
-- 管理员CMD
mysqld --install     //安装MySQL
mysqld --initialize-insecure --user=mysql  //初始化data目录
```

### 基本语句

```mysql
-- SQL大小写不敏感
-- 基本操作语句
flush privileges;  -- 刷新权限
show grants for f4ke; -- 查询权限
show databases;
show tables;
create database f4ke;
use f4ke;
exit; 
```

数据库 xxx 语言  CRUD增删改查

DDL    定义

DML    操作

DQL    查询

DCL    控制

### DML

```mysql

-- 操作表
show create table `表名` -- 查看创建表的语句
desc `表名`  -- 查看表的结构



alter table `表名` rename as `新表名`         -- 修改表名
alter table `表名` add `字段名` 列属性      -- 增加表字段
alter table `表名` modify `字段名` 列属性   -- 修改表字段
alter table `表名` change `旧字段名` `新字段名` `列属性`    -- 字段重命名
alter table `表名` drop `字段名`

drop table [if exists] `表名`  			  -- 删除表

-- insert into `表名` (`字段名1`,`字段名2`,`字段名3`) values('值1','值2','值3')
INSERT INTO `student`(`name`,`class`) VALUES('f4ke','3')
-- insert into `表名` (`字段名1`,`字段名2`,`字段名3`) values('值1','值2','值3'),(),() //多个值 

-- update `表名` set `字段名` = xxx , `字段名` = xxx where [条件]
UPDATE `student` SET `name` = 'horse' WHERE `class` > 3 

delete from 表名 [where 条件]  -- 删除表

truncate 表名  -- 清空表
```



### 创建数据库表

```mysql
-- 创建学生表

-- 学号 int 密码 password 姓名，年级，性别，出生日期，家庭住址

CREATE TABLE IF NOT EXISTS `student` (
   `id` INT(3) NOT NULL AUTO_INCREMENT COMMENT '学号',
   `name` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '姓名',
   `passwd` VARCHAR(30) NOT NULL DEFAULT '123456' COMMENT '密码',
   `class` INT(2) NOT NULL COMMENT '年级',
   `birthday` DATETIME DEFAULT NULL COMMENT '生日',
   `address` VARCHAR(100) DEFAULT NULL COMMENT '地址',
   PRIMARY KEY(`id`)
)ENGINE=INNODB DEFAULT CHARSET=utf8

/**/
-- 格式

CREATE TABLE [IF NOT EXISTS] `表名` (
   `字段名` 数据类型 [可选属性],
   `字段名` 数据类型 [可选属性],
   `字段名` 数据类型 [可选属性],
    ....
   `字段名` 数据类型 [可选属性],
   PRIMARY KEY(`字段名`)
)ENGINE=INNODB DEFAULT CHARSET=utf8
```

### DQL（重要）

```mysql
SELECT[ALL|DISTINCT|DISTINCTROW|TOP]
{*|talbe.*|[table.]field1[AS alias1][,[table.]field2[AS alias2][,…]]}
FROM tableexpression[,…][IN externaldatabase]
	[left | right | inner join table_name2]  -- 联合查询
	[WHERE…]                   -- 判断指定条件
	[GROUP BY…]                -- 按指定字段分组
	[HAVING…]                  -- 分组之后必须满足的次要条件
	[ORDER BY…]                -- 指定查询结果按照一个或多个条件排序
	[limit …]                  -- 指定查询记录从哪里开始的多少条


-- DQL == Data Query Language 数据查询语言
-- select
select * from 表名

-- 拼接函数：concat()
select concat(a,b) from 表名
-- AS 给字段起别名

-- 去重 distinct 查询结果中重复的字段
select distinct * from 表名

-- where 子句 + （AND OR NOT 逻辑运算符）

-- 模糊查询：比较运算符
like '%xxx%'
in ('xxx')  -- 精确匹配，匹配具体的字段值
is null
is not null

-- 联表查询
select studentNo,name 
from student as s
inner join grade as g
on s.studentNo = g.studentNo   -- 所查询的字段值左右两表有就会有

left join  -- 所查询的字段值只有左表有，查询结果就会有，哪怕右表没有相关记录（NULL）
right join -- 所查询的字段值只有有表有，查询结果就会有

-- 分页
limit n,m  -- 从第 n 条记录到 第m 条


-- 排序
order by `No` desc
asc -- 升序
desc -- 降序


-- union 
SELECT expression1, expression2, ... expression_n
FROM tables
[WHERE conditions]
UNION [ALL | DISTINCT]
SELECT expression1, expression2, ... expression_n
FROM tables
[WHERE conditions];

mysql> select * from student union select 1,2,3,4,5,6;
+----+-------+--------+-------+----------+---------+
| id | name  | passwd | class | birthday | address |
+----+-------+--------+-------+----------+---------+
|  1 | f4ke  | 123456 |     3 | NULL     | NULL    |
|  2 | f4ke  | 123456 |     3 | NULL     | NULL    |
|  3 | horse | 123456 |     5 | NULL     | NULL    |
|  4 | horse | 123456 |     6 | NULL     | NULL    |
|  5 | horse | 123456 |     5 | NULL     | NULL    |
|  1 | 2     | 3      |     4 | 5        | 6       |
+----+-------+--------+-------+----------+---------+
6 rows in set (0.00 sec)

-- 聚合函数
count()  -- 计数，统计表中的记录
avg()  -- 平均值
sum()  -- 求和
 
```

### 事务

> 原则：ACID原则  原子性 *atomicity*  一致性 *consistency* 隔离性  *isolation* 持久性 *durability*



### 用户管理

[MySQL之权限管理](https://www.cnblogs.com/Richardzhu/p/3318595.html)

用户表： mysql.user

```mysql
-- 创建用户
create user f4ke identified by '密码' 

-- 删除用户
drop user

-- 修改密码
set password for f4ke = password('新密码')

-- 重命名
rename user f4ke to f4ke2

-- 用户授权
grant all privileges on *.* to f4ke

-- 查询权限
show grants for f4ke

-- 撤销权限
revoke all privileges on *.* to f4ke
```

[MySQL 查看用户授予的权限](https://www.cnblogs.com/kerrycode/p/7423850.html)--从全局层级、数据库层级、表层级、列层级、子程序层级不同维度进行权限的授予并查看权限

## MySQL权限详情

**（以下操作都是以root身份登陆进行grant授权，以root@localhost身份登陆执行各种命令。）**

[**MySQL**](https://cloud.tencent.com/product/cdb?from=10680)**包含哪些权限，共29个。**

| 权限                    | 说明                                                         | 举例                                                         |
| :---------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| usage                   | 连接（登陆）权限，建立一个用户，就会自动授予其usage权限（默认授予）。    该权限只能用于数据库登陆，不能执行任何操作；且usage权限不能被回收，也即REVOKE用户并不能删除用户。 | mysql>  grant usage on *.* to 'root′@'localhost' identified by '123'; |
| file                    | 拥有file权限才可以执行  select ..into outfile和load data infile…操作，但是不要把file, process,  super权限授予管理员以外的账号，这样存在严重的安全隐患。 | mysql>  grant file on *.* to root@localhost;    mysql> load data infile '/home/mysql/pet.txt' into table pet; |
| super                   | 这个权限允许用户终止任何查询；修改全局变量的SET语句；使用CHANGE  MASTER，PURGE MASTER LOGS。 | mysql>  grant super on *.* to root@localhost;    mysql> purge master logs before 'mysql-bin.000006′; |
| select                  | 必须有select的权限，才可以使用select  table                  | mysql>  grant select on pyt.* to 'root′@'localhost';    mysql> select * from shop; |
| insert                  | 必须有insert的权限，才可以使用insert  into ….. values….      | mysql>  grant insert on pyt.* to 'root′@'localhost';    mysql> insert into shop(name) values('aa'); |
| update                  | 必须有update的权限，才可以使用update  table                  | mysql>  update shop set price=3.5 where article=0001 and dealer='A'; |
| delete                  | 必须有delete的权限，才可以使用delete  from ….where….(删除表中的记录) | mysql>  grant delete on pyt.* to 'root′@'localhost';    mysql> delete from table where id=1; |
| alter                   | 必须有alter的权限，才可以使用alter  table                    | mysql>  alter table shop modify dealer char(15);             |
| alter routine           | 必须具有alter  routine的权限，才可以使用{alter \|drop} {procedure\|function} | mysql>grant  alter routine on pyt.* to 'root′@' localhost ‘;    mysql> drop procedure pro_shop;    Query OK, 0 rows affected (0.00 sec) |
| create                  | 必须有create的权限，才可以使用create  table                  | mysql>  grant create on pyt.* to 'root′@'localhost';         |
| drop                    | 必须有drop的权限，才可以删除库、表、索引、视图等             | mysql>  drop database db_name;     mysql> drop table tab_name;    mysql> drop view vi_name;     mysql> drop index in_name; |
| create routine          | 必须具有create  routine的权限，才可以使用{create \|alter\|drop} {procedure\|function} | mysql>  grant create routine on pyt.* to 'root′@'localhost';    当授予create routine时，自动授予EXECUTE, ALTER ROUTINE权限给它的创建者： |
| create temporary tables | (注意这里是tables，不是table)                                | 必须有create  temporary tables的权限，才可以使用create temporary tables.    mysql> grant create temporary tables on pyt.* to  'root′@'localhost';    [mysql@mydev ~]$ mysql -h localhost -u root -p pyt    mysql> create temporary table tt1(id int); |
| create view             | 必须有create  view的权限，才可以使用create view              | mysql>  grant create view on pyt.* to 'root′@'localhost';    mysql> create view v_shop as select price from shop; |
| create user             | 要使用CREATE  USER，必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 | mysql>  grant create user on *.* to 'root′@'localhost';    或：mysql> grant insert on *.* to root@localhost; |
| show database           | 通过show  database只能看到你拥有的某些权限的数据库，除非你拥有全局SHOW DATABASES权限。    对于root@localhost用户来说，没有对mysql数据库的权限，所以以此身份登陆查询时，无法看到mysql数据库： | mysql>  show databases;                                      |
| show view               | 必须拥有show  view权限，才能执行show create view             | mysql>  show create view name;                               |
| index                   | 必须拥有index权限，才能执行[create  \|drop] index            | mysql>  grant index on pyt.* to root@localhost;    mysql> create index ix_shop on shop(article);    mysql> drop index ix_shop on shop; |
| excute                  | 执行存在的Functions,Procedures                               | mysql>  call pro_shoroot(0001,@a)；                          |
| event                   | event的使用频率较低建议使用root用户进行创建和维护。    要使event起作用，MySQL的常量GLOBAL event_scheduler必须为on或者是1 | mysql>  show global variables like 'event_scheduler';        |
| lock tables             | 必须拥有lock  tables权限，才可以使用lock tables              | mysql>  grant lock tables on pyt.* to root@localhost;    mysql> lock tables a1 read;    mysql> unlock tables; |
| references              | 有了REFERENCES权限，用户就可以将其它表的一个字段作为某一个表的外键约束。 |                                                              |
| reload                  | 必须拥有reload权限，才可以执行flush  [tables \| logs \| privileges] | mysql>  grant reload on pyt.* to root@localhost;    ERROR 1221 (HY000): Incorrect usage of DB GRANT and GLOBAL PRIVILEGES    mysql> grant reload on *.* to 'root′@'localhost';    Query OK, 0 rows affected (0.00 sec)    mysql> flush tables; |
| replication client      | 拥有此权限可以查询master  server、slave server状态。         | mysql>  grant Replication client on *.* to root@localhost;    或：mysql> grant super on *.* to root@localhost;    mysql> show master status; |
| replication slave       | 拥有此权限可以查看从服务器，从主服务器读取二进制日志。       | mysql>  grant replication slave on *.* to root@localhost;    mysql> show slave hosts;    Empty set (0.00 sec)    mysql>show binlog events; |
| Shutdown                | 关闭mysql权限                                                | [mysql@mydev  ~]$ mysqladmin shutdown                        |
| grant option            | 拥有grant  option，就可以将自己拥有的权限授予其他用户（仅限于自己已经拥有的权限） | mysql>  grant Grant option on pyt.* to root@localhost;    mysql> grant select on pyt.* to p2@localhost; |
| process                 | 通过这个权限，用户可以执行SHOW  PROCESSLIST和KILL命令。默认情况下，每个用户都可以执行SHOW PROCESSLIST命令，但是只能查询本用户的进程。 | mysql>  show processlist;                                    |
| all privileges          | 所有权限。with  grant option 可以连带授权                    | mysql>  grant all privileges on pyt.* to root@localhost with grant option; |

**另外，管理权限（如 super， process， file等）不能够指定某个数据库，on后面必须跟 \*.\***

### MySQL注入

* [MySQL 5.7 学习：安全相关特性](https://www.cnblogs.com/zhoujinyi/p/5627494.html)

注入类型及原理？

提权方法？ MOF UDF？







# 阶段四：Javaweb

## Maven

软件项目管理及自动构建工具，由Apache软件基金会所提供。

用它来导入jar包

Maven核心思想：**约定大于配置**

配置阿里云镜像

```xml
<mirror>
    <id>nexus-aliyun</id>
    <mirrorOf>central</mirrorOf>
    <name>Nexus aliyun</name>
    <url>http://maven.aliyun.com/nexus/content/groups/public</url>
</mirror>

<!-- shift + tab 整块代码缩进 -->
```

配置本地仓库

* 建立本地仓库：localRepository

```xml
<localRepository>E:\Java\apache-maven-3.6.3\maven-repo</localRepository>
```

## Servlet

* Servlet是sun公司开发动态web的一门技术
* Sun公司在这些API中提供一个接口叫做：Servlet

把实现了Servlet接口的Java程序叫做，Servlet

### 原理

![image-20200522185649419](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200522185649419.png)

### Hello Servlet

修改web.xml为最新版

```xml
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0" metadata-complete="true">
    ...
</web-app>
```

编写一个Servlet程序，实现Servlet接口，直接继承HttpServlet

```java
public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("doGet!");
        PrintWriter writer = resp.getWriter();
        writer.print("Hello Servlet!");

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

编写Servlet的映射

```xml
    <servlet>
        <servlet-name>hello</servlet-name>
        <servlet-class>com.f4ke.servlet.HelloServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>hello</servlet-name>
        <url-pattern>/hello</url-pattern>
    </servlet-mapping>
```

### ServletContext

web容器启动的时候，会为每个web程序都创建一个对应的ServletContext对象（个人理解：上下文对象，就是中介），它代表了当前的web应用，它可以用来

##### 共享数据

HelloServlet.java

```java
public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext servletContext = this.getServletContext();

        String username = "f4ke";
        servletContext.setAttribute("username",username);
        System.out.println("Hello!");
    }
}
```

GetServlet.java

```java
public class GetServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext servletContext = this.getServletContext();
        String username = (String) servletContext.getAttribute("username");
        resp.getWriter().print(username);
    }
}
```

web.xml

```xml
<servlet>
  <servlet-name>hello</servlet-name>
  <servlet-class>com.f4ke.servlet.HelloServlet</servlet-class>
</servlet>
<servlet-mapping>
  <servlet-name>hello</servlet-name>
  <url-pattern>/hello</url-pattern>
</servlet-mapping>

<servlet>
  <servlet-name>gp</servlet-name>
  <servlet-class>com.f4ke.servlet.GetServlet</servlet-class>
</servlet>
<servlet-mapping>
  <servlet-name>gp</servlet-name>
  <url-pattern>/gp</url-pattern>
```

#### 获取初始参数

#### 请求转发

web.xml

```xml
  <servlet>
    <servlet-name>sd3</servlet-name>
    <servlet-class>com.f4ke.servlet.HelloServletDemo03</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>sd3</servlet-name>
    <url-pattern>/sd3</url-pattern>
  </servlet-mapping>
```

HelloServletDemo03.java

```java
public class HelloServletDemo03 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("HelloServletDemo03!");
        this.getServletContext().getRequestDispatcher("/gp").forward(req,resp);
    }
}
```

#### 读取资源文件

ServlletDemo01.java

```java
public class ServlletDemo01 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        InputStream is = this.getServletContext().getResourceAsStream("/WEB-INF/classes/db.properties");

        Properties prop = new Properties();
        prop.load(is);
        String user = prop.getProperty("username");
        String pwd = prop.getProperty("passwd");
        resp.getWriter().print(user+":"+pwd);

    }
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

web.xml

```xml
  <servlet>
    <servlet-name>gr</servlet-name>
    <servlet-class>com.f4ke.servlet.ServlletDemo01</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>gr</servlet-name>
    <url-pattern>/gr</url-pattern>
  </servlet-mapping>
```

### HttpServletResponse

#### 下载文件

#### 验证码实现

ImageServlet.java

```java
public class ImageServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //浏览器3秒刷新一次
        resp.setHeader("refresh","3");
        //在内存中创建图片
        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);
        //得到图片
        Graphics2D g = (Graphics2D) image.getGraphics();
        //设置图片背景颜色
        g.setColor(Color.WHITE);
        g.fillRect(0,0,80,20);
        //在图片中写入数据
        g.setColor(Color.RED);
        g.setFont(null);
        g.drawString(makeNum(),0,20);

        //告诉浏览器该请求用图片方式打开
        resp.setContentType("image/png");

        //取消浏览器缓存
        resp.setDateHeader("expires",-1);
        resp.setHeader("cache-contorl","no-cache");

        //把图片给浏览器
        ImageIO.write(image,"png",resp.getOutputStream());

    }


    private String makeNum(){
        Random random = new Random();
        String num = random.nextInt(9999999) + "";
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < 7-num.length(); i++) {
            sb.append("0");
        }
        num = sb.toString() + num ;
        return num;
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

web.xml

```xml
<servlet>
    <servlet-name>ImageServlet</servlet-name>
    <servlet-class>com.f4ke.servlet.ImageServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>ImageServlet</servlet-name>
    <url-pattern>/img</url-pattern>
</servlet-mapping>
```

#### 重定向

```java
public class RedirectServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.sendRedirect("/r1/img"); //注意重定向的路径为项目名下的文件
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

### HttpServletRequest

（get/post获取参数）/请求转发 

## Cookie/Session(重点)

**cookie**

- 客户端技术   （响应，请求）

**session**

- 服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！

服务器会给每一个用户（浏览器）创建一个session对象

[sessionid如何产生？由谁产生？保存在哪里？](https://www.cnblogs.com/woshimrf/p/sessionid.html)

使用session:

```java
public class Demo01 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //解决乱码
        req.setCharacterEncoding("UTF-8");
        resp.setContentType("text/html; charset=utf-8");

        //得到session(创建session)
        HttpSession session = req.getSession();

        //添加session数据
        session.setAttribute("name",new Person("f4ke",1));

        //得到sessionId
        String sessionId = session.getId();
        //判断
        if(session.isNew()){
            resp.getWriter().print("session创建成功："+sessionId);
        }else {
            resp.getWriter().print("你已经创建了session了"+sessionId);
        }
        
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

// 获取session
//得到session(创建session)
HttpSession session = req.getSession();

Person name = (Person) session.getAttribute("name");

resp.getWriter().print(name.toString());
// 注销session
HttpSession session = req.getSession();
session.removeAttribute("name");
session.invalidate();
```

web.xml

```xml
<servlet>
  <servlet-name>Demo01</servlet-name>
  <servlet-class>com.f4ke.servlet.Demo01</servlet-class>
</servlet>
<servlet-mapping>
  <servlet-name>Demo01</servlet-name>
  <url-pattern>/s1</url-pattern>
</servlet-mapping>

<servlet>
  <servlet-name>Demo02</servlet-name>
  <servlet-class>com.f4ke.servlet.Demo02</servlet-class>
</servlet>
<servlet-mapping>
  <servlet-name>Demo02</servlet-name>
  <url-pattern>/s2</url-pattern>
</servlet-mapping>

<servlet>
  <servlet-name>Demo03</servlet-name>
  <servlet-class>com.f4ke.servlet.Demo03</servlet-class>
</servlet>
<servlet-mapping>
  <servlet-name>Demo03</servlet-name>
  <url-pattern>/s3</url-pattern>
</servlet-mapping>

  <!-- 设置session过期时间-->
  <session-config>
    <session-timeout>15</session-timeout>
  </session-config>
```

## JSP

### JSP原理

![image-20200526155241460](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200526155241460.png)

**JSP 本质上就是一个Servlet**

在JSP页面中；

只要是 JAVA代码就会原封不动的输出；

如果是HTML代码，就会被转换为：

```java
out.write("<html>\r\n");
```

这样的格式，输出到前端！

### JSP学习

JSP作为java技术的一种应用，支持java所有语法

pom.xml依赖：

```xml
<dependencies>
    <!-- Servlet依赖 -->
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>servlet-api</artifactId>
        <version>2.5</version>
    </dependency>
    <!--  JSP依赖-->
    <dependency>
        <groupId>javax.servlet.jsp</groupId>
        <artifactId>javax.servlet.jsp-api</artifactId>
        <version>2.3.3</version>
    </dependency>
    <!--  jstl表达式依赖-->
    <dependency>
        <groupId>javax.servlet.jsp.jstl</groupId>
        <artifactId>javax.servlet.jsp.jstl-api</artifactId>
        <version>1.2.2</version>
    </dependency>
    <!--  标签依赖-->
    <dependency>
        <groupId>taglibs</groupId>
        <artifactId>standard</artifactId>
        <version>1.1.2</version>
    </dependency>
</dependencies>
```

### JSP表达式

```jsp
<%--jsp的注释，不会再客户端显示，html的就会--%>
<%-- JSP表达式 --%>
<%= new java.util.Date()%>
```

### JSP脚本片段

```jsp
<%-- jsp声明 --%>
<%!%>
```

### EL表达式

```el
${}
```



## MVC

Model:  View:JSP  Controller:Servlet

![image-20200526163207227](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200526163207227.png)

## Filter(重点)

Filter：过滤器 ，用来过滤网站的数据；

- 处理中文乱码
- 登录验证….

过滤乱码

show.java

```java
public class Show extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        resp.getWriter().write("新的风暴已经出现！");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

CharacterEncodingFilter.java

```java
public class CharacterEncodingFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("正在初始化");  //服务器启动时，过滤器初始化
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        servletRequest.setCharacterEncoding("UTF-8");
        servletResponse.setContentType("text/html;charset=utf-8");
        System.out.println("CharacterEncodingFilter执行前");
        filterChain.doFilter(servletRequest,servletResponse);  //让过滤器链走下去
        System.out.println("CharacterEncodingFilter执行后");
    }

    @Override
    public void destroy() {
        System.out.println("正在销毁"); //服务器关闭时，过滤器会销毁
    }
}
```

mapping

```xml
<servlet>
    <servlet-name>Show</servlet-name>
    <servlet-class>com.f4ke.servlet.Show</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>Show</servlet-name>
    <url-pattern>/show</url-pattern>
</servlet-mapping>
<servlet-mapping>
    <servlet-name>Show</servlet-name>
    <url-pattern>/servlet/show</url-pattern>
</servlet-mapping>

<filter>
    <filter-name>CharacterEncodingFilter</filter-name>
    <filter-class>com.f4ke.filter.CharacterEncodingFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <!-- servlet目录下的所有请求都走过滤器   -->
    <url-pattern>/servlet/*</url-pattern>
</filter-mapping>
```

## JDBC（Java Database Connectivity）

![image-20200422175214356](https://i.loli.net/2020/04/28/UIxBJiGbgcv52y7.png)


JAVA连接数据库
```java

public class JdbcDemo01 {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //配置连接信息
        String url = "jdbc:mysql://localhost:3306/f4ke?useSSL=false&serverTimezone=UTC";
//        static final String DB_URL = "jdbc:mysql://localhost:3306/empmgs?useSSL=false&serverTimezone=UTC";
        String name = "root";
        String password  = "Ea72*t@7";

        //1,加载驱动
        Class.forName("com.mysql.jdbc.Driver");

        //2,连接数据库，也代表数据库
        Connection connection = DriverManager.getConnection(url, name, password);

        //3,向数据库发送SQL的对象：Statement 进行CRUD的操作
        Statement statement = connection.createStatement();

        //4,编写SQL
        String sql = "select * from jdbc_test";

        //5,执行SQL
        ResultSet rs = statement.executeQuery(sql);

        while (rs.next()){
            System.out.println("id:"+rs.getObject("id"));
            System.out.println("name:"+rs.getObject("name"));
            System.out.println("password:"+rs.getObject("password"));
            System.out.println("email:"+rs.getObject("email"));
            System.out.println("birthday:"+rs.getObject("birthday"));
        }

        //6,关闭连接，释放资源 （先开的后关）
        rs.close();
        statement.close();
        connection.close();

    }
}

```

预编译SQL

```java
public class JdbcDemo01 {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //配置连接信息
        String url = "jdbc:mysql://localhost:3306/f4ke?useSSL=false&serverTimezone=UTC";
//        static final String DB_URL = "jdbc:mysql://localhost:3306/empmgs?useSSL=false&serverTimezone=UTC";
        String name = "root";
        String password  = "Ea72*t@7";

        //1,加载驱动
        Class.forName("com.mysql.jdbc.Driver");

        //2,连接数据库，也代表数据库
        Connection connection = DriverManager.getConnection(url, name, password);

        //3,编写SQL
        String sql = "insert into jdbc_test(id, name, password, email, birthday) values (?,?,?,?,?);";

        //4,预编译SQL
        PreparedStatement preparedStatement = connection.prepareStatement(sql);

        preparedStatement.setInt(1,4);
        preparedStatement.setString(2,"f4ke");
        preparedStatement.setString(3,"123456");
        preparedStatement.setString(4,"123456@qq.com");
        preparedStatement.setString(5,"2015-6-6");
        //5,执行SQL
        int rs = preparedStatement.executeUpdate();
        if (rs > 0){
            System.out.println("执行成功！");
//            System.out.println("name:"+rs.getObject("name"));
//            System.out.println("password:"+rs.getObject("password"));
        }

        //6,关闭连接，释放资源 （先开的后关）
//        rs.close();
        preparedStatement.close();
        connection.close();

    }
}
```

# 阶段五：SSM框架

## MyBatis

- MyBatis 是一款优秀的**持久层框架**
- 它支持定制化 SQL、存储过程以及高级映射。
- MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。

### 第一个MyBatis程序

#### 新建项目

* 新建一个普通的maven项目
* 删除src目录
* 导入maven依赖

```xml
<!--  配置依赖-->
<dependencies>
    <!--  mysql驱动-->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>5.1.47</version>
    </dependency>
    <!-- mybatis -->
    <dependency>
        <groupId>org.mybatis</groupId>
        <artifactId>mybatis</artifactId>
        <version>3.5.4</version>
    </dependency>
    <!-- junit -->
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.13</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

#### 创建一个模块

* 编写mybatis的核心配置文件--mybatis-config.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<!--configuration核心配置文件-->
<configuration>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;serverTimezone=UTC"/>
                <property name="username" value="root"/>
                <property name="password" value="Ea72*t@7"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <!-- 每一个Mapper.xml都需要在Mybatis核心配置文件中注册  -->
        <mapper resource="com/f4ke/dao/UserMapper.xml"/>
    </mappers>
</configuration>
```

* 编写mybatis工具类---MybatisUtils.class

```java
package com.f4ke.utils;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;

//sqlSessionFactory  --> sqlSession
public class MybatisUtils {

    private  static  SqlSessionFactory sqlSessionFactory;
    static {
        try {
            //使用MyBatis第一步：获取SqlSessionFactory对象
            String resource = "mybatis-config.xml";
            InputStream inputStream = Resources.getResourceAsStream(resource);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    //既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。
    // SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法
    public static SqlSession getSqlSession(){
        return sqlSessionFactory.openSession();
    }


}
```

#### 编写代码

* 实体类--User.class

```java
package com.f4ke.pojo;

//实体类
public class User {
    private int id;
    private String name;
    private String pwd;

    public User() {
    }

    public User(int id, String name, String pdw) {
        this.id = id;
        this.name = name;
        this.pwd = pdw;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPdw() {
        return pwd;
    }

    public void setPdw(String pdw) {
        this.pwd = pdw;
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", pdw='" + pwd + '\'' +
                '}';
    }
}
```

* Dao接口--UserDao

```java
package com.f4ke.dao;

import com.f4ke.pojo.User;

import java.util.List;

public interface UserDao {
    List<User> getUserList();

}
```

* 接口实现类由原来的UserDaoImpl转变为一个 Mapper配置文件.--UserMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--namespace 绑定一个对应的Dao/Mapper接口-->
<mapper namespace="com.f4ke.dao.UserDao">
<!--select 查询语句-->
    <select id="getUserList" resultType="com.f4ke.pojo.User">
    select * from user
  </select>
</mapper>
```

#### junit测试

```java
package com.f4ke.dao;

import com.f4ke.pojo.User;
import com.f4ke.utils.MybatisUtils;
import org.apache.ibatis.session.SqlSession;
import org.junit.Test;

import java.util.List;

public class UserDaoTest {

    @Test
    public void test(){
        //获得SqlSession对象
        SqlSession sqlSession = MybatisUtils.getSqlSession();

        //执行SQL
        UserDao mapper = sqlSession.getMapper(UserDao.class);
        List<User> userList =  mapper.getUserList();

        for (User user : userList){
            System.out.println(user);
        }

        //一定要关闭SqlSession
        sqlSession.close();
    }
}
```

### 增删改查（CRUD）

UserMapper接口

```java
package com.f4ke.dao;

import com.f4ke.pojo.User;

import java.util.List;

public interface UserMapper {
    //查询全部用户
    List<User> getUserList();

    //根据id查询用户
    User getUserById(int id);

    //插入数据
    int addUser(User user);

    //更新数据
    int updateUser(User user);

    //删除数据
    int deleteUser(int id);

}
```

UserMapper.xml配置文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--namespace 绑定一个对应的Dao/Mapper接口-->
<mapper namespace="com.f4ke.dao.UserMapper">
<!--select 查询语句-->
    <select id="getUserList" resultType="com.f4ke.pojo.User">
        select * from mybatis.user;
    </select>

    <select id="getUserById" parameterType="int" resultType="com.f4ke.pojo.User">
        select * from mybatis.user where id = #{id};
    </select>
    
    <insert id="addUser" parameterType="com.f4ke.pojo.User">
        insert into mybatis.user (id, name, pwd) values (#{id},#{name},#{pwd});
    </insert>

    <update id="updateUser" parameterType="com.f4ke.pojo.User">
        update mybatis.user set name = #{name}, pwd = #{pwd} where id = #{id};
    </update>
    
    <delete id="deleteUser" parameterType="int">
        delete from mybatis.user where id = #{id};
    </delete>
</mapper>
```

junit测试

```java
package com.f4ke.dao;

import com.f4ke.pojo.User;
import com.f4ke.utils.MybatisUtils;
import org.apache.ibatis.session.SqlSession;
import org.junit.Test;

import java.sql.PreparedStatement;
import java.util.List;
import java.util.Properties;

public class UserMapperTest {

    @Test
    public void test(){
        //获得SqlSession对象
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        //执行SQL
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        List<User> userList =  mapper.getUserList();
        for (User user : userList){
            System.out.println(user);
        }
        //关闭SqlSession
        sqlSession.close();
    }

    @Test
    public void test02(){
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        User id = mapper.getUserById(1);
        System.out.println(id);
        sqlSession.close();
    }

    @Test
    public void test03(){
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        int i = mapper.addUser(new User(5,"kkkk","666666"));
        if(i > 0){
            System.out.println("插入成功！");
        }
//        sqlSession.commit(); 一定要记得提交事务
        sqlSession.close();
    }


    @Test
    public void testUpdate(){
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);

        int hehe = mapper.updateUser(new User(1, "hehe", "456789"));
        if(hehe > 0){
            System.out.println("更新成功！");
        }
        sqlSession.commit();
        sqlSession.close();
    }

    @Test
    public void deleteUser(){
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        int i = mapper.deleteUser(2);
        if(i>0){
            System.out.println("删除成功");
        }
        sqlSession.commit();
        sqlSession.close();
    }
}
```

#### 动态SQL

### 缓存

缓存就是提高查询的效率，80%的数据库操作都是查询语句，所以为了提高查询效率，使用缓存技术

用户 --》二级缓存（namespace） --》 一级缓存（sqlSession） --》 数据库

![image-20200615112218066](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200615112218066.png)



## Spring

Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架

* Spring是一个开源免费的容器（框架），轻量级，非入侵式的框架

* 控制反转（IOC）/面向切面编程（AOP）
* 支持对事物的处理，支持框架的整合

SSH：Structs2 + Spring + Hibernate

SSM: SpringMVC + Spring + Mybatis

官网：https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/

GitHub：https://github.com/spring-projects/spring-framework

maven依赖

```xml
<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.2.7.RELEASE</version>
</dependency>

<!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>5.2.7.RELEASE</version>
</dependency>

```

### IoC

控制反转 IoC (Inversion of Control):个人理解就是将对象的创建主动权转让给用户，用户想要什么样得功能就选择什么样的功能，程序员只是提供若干个不同的接口即可

**IoC 为Spring框架的核心内容**：本质是一种思想

![image-20200615180510567](https://files.catbox.moe/ym8eg8.png)

beans.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="MysqlImpl" class="com.f4ke.dao.UserDaoMysqlImpl"/>
    <bean id="Impl" class="com.f4ke.dao.UserDaoImpl"/>
    <bean id="OracleImpl" class="com.f4ke.dao.UserDaoOracleImpl"/>
    <bean id="ServiceImpl" class="com.f4ke.service.UserServiceImpl">
        <property name="userdao" ref="Impl"/>
    </bean>

</beans>
```

测试

```java
import com.f4ke.dao.UserDaoMysqlImpl;
import com.f4ke.dao.UserDaoOracleImpl;
import com.f4ke.service.UserServiceImpl;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Mytest {
    public static void main(String[] args) {
        ApplicationContext Context = new ClassPathXmlApplicationContext("beans.xml");

        UserServiceImpl serviceImpl = (UserServiceImpl) Context.getBean("ServiceImpl");

        serviceImpl.getUser();

    }
}
```

IoC创建对象的方式

* 默认：无参构造创建对象
* 有参构造

```xml
<!--    &lt;!&ndash;不建议使用&ndash;&gt;-->
<!--    <bean id="user" class="com.f4ke.pojo.User">-->
<!--        <constructor-arg type="java.lang.String" value="f4ke"/>-->
<!--    </bean>-->
    
<!-- 建议方式   -->
    <bean id="user" class="com.f4ke.pojo.User">
        <constructor-arg name="name" value="f4ke"/>
    </bean>
```

### 依赖注入（DI）【重点】

applicationcontext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="address" class="com.f4ke.pojo.Address">
        <property name="address" value="厦门"/>
    </bean>
    <bean id="student" class="com.f4ke.pojo.Student">
        <property name="name" value="f4ke"/>
        <property name="address" ref="address"/>
        <property name="books">
            <array>
                <value>淘气包马小跳</value>
                <value>皮皮鲁</value>
                <value>冒险小虎队</value>
            </array>
        </property>
        <property name="hobbies">
            <list>
                <value>唱跳</value>
                <value>RAP</value>
                <value>篮球</value>
            </list>
        </property>
        <property name="card">
            <map>
                <entry key="IDcard" value="350125199706013295"/>
            </map>
        </property>
        <property name="games">
            <set>
                <value>跳皮筋</value>
            </set>
        </property>
        <property name="info">
            <props>
                <prop key="性别">男</prop>
                <prop key="年龄">13</prop>
                <prop key="爱好">篮球</prop>
            </props>
        </property>
        <property name="wife">
            <null/>
        </property>

    </bean>
</beans>
```

```java
Address{
    name='f4ke', 
    address=Address{address='厦门'}, 
    books=[淘气包马小跳, 皮皮鲁, 冒险小虎队], 
    hobbies=[唱跳, RAP, 篮球], 
    card={
        IDcard=350125199706013295
    }, 
    games=[跳皮筋], 
    wife='null', 
    info={
        性别=男, 
        爱好=篮球, 
        年龄=13
    }
}
```

### Bean的自动装配【重点】

byname自动装配

```xml
<!--
byname: 会自动在容器的上下文中查找，和对象属性对应的beanid
-->
<bean id="people" class="com.f4ke.pojo.People" autowire="byName">
    <property name="name" value="f4ke"/>
</bean>
```

bytype自动装配

```xml
<!--
byName: 会自动在容器的上下文中查找，和属性对应的beanid
byType: 会自动在容器的上下文中查找，和属性类型对应的bean
-->
<bean id="people" class="com.f4ke.pojo.People" autowire="byType">
    <property name="name" value="f4ke"/>
</bean>
```

### 使用注解实现自动装配

```java
public class People {
@Autowired
@Qualifier(value = "dog22")
private Dog dog;
@Autowired
@Qualifier(value = "cat222")
private Cat cat;
```

### 注解开发

```markdown
- @Autowired 直接在属性上使用即可 跟踪byType

- @Qualifier(value = "dog22") 若bean 与 beanid 同时为多个，使用Qualifier指定beanid

- @Resource  java原生注解，结合了@Autowired与@Qualifier

- @Component 组件，放在类上，等价于bean id="user" class="com.f4ke.pojo.User"/>
 
- @Value("f4ke") 等价于为属性赋值
```

### 静态代理模式

代理模式的好处：

* 使真实角色更加纯粹，不用关注公共业务
* 公共业务交给代理角色去做，实现业务分工
* 若公共业务发生了扩展，可方便进行管理

![image-20200617175449119](https://files.catbox.moe/ywvq4w.png)

角色分析：

* 抽象角色：一般使用接口或者抽象类解决

```java
package com.f4ke.demo01;

public interface Rent {
    public void rent();
}
```

* 真实角色：被代理的角色

```java
package com.f4ke.demo01;

public class Landlord implements Rent{

    @Override
    public void rent() {
        System.out.println("房东要出租房子...");
    }
}
```

* 代理角色：代理真实角色，一般会附属一些通用的可复用的行为

```java
package com.f4ke.demo01;

public class Proxy implements Rent{
    private Landlord landlord;

    public Proxy() {
    }

    public Proxy(Landlord landlord) {
        this.landlord = landlord;
    }

    @Override
    public void rent() {
        seeHouse();
        landlord.rent();
        money();
    }

    public void money(){
        System.out.println("中介费");
    }

    public void seeHouse(){
        System.out.println("中介带你看房");
    }
}
```

* 客户端：客户

```java
package com.f4ke.demo01;

public class Client {
    public static void main(String[] args) {
        Landlord landlord = new Landlord();

        Proxy proxy = new Proxy(landlord);

        proxy.rent();
    }
}
```

### 动态代理模式

* 动态代理与静态代理角色一样
* 代理类是动态生成的，不是我们直接写好的
* 分为两大类：基于接口的动态代理，基于类的动态代理
  * 基于接口：JDK动态代理
  * 基于类： cglib
  * java字节码



**结合javaSE反射理解动态代理模式** 

* Proxy类 提供了动态生成代理类的静态方法
* InvocationHandler接口 代理类的调用程序实现的接口

ProxyInvocationHander 此类动态生成代理对象

```java
package com.f4ke.demo04;

import com.f4ke.demo01.Rent;
import com.f4ke.demo02.ServiceImpl;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

//用此类动态生成代理对象
public class ProxyInvocationHander implements InvocationHandler {

    //被代理的接口
    private Object target;

    public void setTarget(ServiceImpl rent) {
        this.target = rent;
    }

    //生成得到代理类
    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);

    }

    //处理代理实例，并返回结果
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        log(method.getName());
        Object result = method.invoke(target,args);
        return result;
    }

    public void log(String funName){
        System.out.println("启动了"+funName+"方法");
    }
}
```

客户端 Client

```java
package com.f4ke.demo04;

import com.f4ke.demo02.Service;
import com.f4ke.demo02.ServiceImpl;
import org.springframework.objenesis.instantiator.basic.ProxyingInstantiator;

public class Client {
    public static void main(String[] args) {
        //创建真实对象
        ServiceImpl rService = new ServiceImpl();

        //创建动态类
        ProxyInvocationHander pih = new ProxyInvocationHander();

        //设置所要代理的真实对象
        pih.setTarget(rService);

        //创建代理对象
        Service proxy = (Service) pih.getProxy();

        //使用代理对象做出行为
        proxy.add();

    }
}
```



### 面向切面编程（AOP）

**Aspect Oriented Programming** 

![image-20200618105132657](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200618105132657.png)



AOP基本概念：

1. 连接点(Joinpoint):类中的所有方法

2. 切入点(Pointcut)：具有共性功能代码的方法

3. 通知(Advice)：被抽取的共性功能的代码逻辑，通知有位置区分，前置通知、后置通知、环绕通知

4. 引入(Introduction)：通知只能抽取逻辑代码，变量是拿不出来的，把变量引入到切入点方法中去，就需要用到引入

5. 目标对象(Target Object)：有切入点方法的对象

6. AOP代理(AOP Proxy)：Spring代理目标对象就叫做AOP代理

7. 织入(Weaving):代理对象把通知织入到目标对象的切入点方法中的，是一个动作

8. 切面(Aspect)：通知和切入点之间的关系

   

#### AOP实现方式一：使用Spring的原生API接口

```xml
<bean id="userService" class="com.f4ke.service.UserServiceImpl"/>
<bean id="log" class="com.f4ke.log.Log"/>
<bean id="afterLog" class="com.f4ke.log.AfterLog"/>

<!--使用Spring的原生API接口-->
<aop:config>
    <!--
        execution(修饰符 返回值 包名.类名/接口名.方法名(参数列表))注意老师忽略掉修饰符了 自己可以写上修饰符试试
        (..)可以代表所有参数,(*)代表一个参数,(*,String)代表第一个参数为任何值,第二个参数为String类型.
    -->
    <aop:pointcut id="pointcut" expression="execution(* com.f4ke.service.UserServiceImpl.*(..))"/>
    
    <!--通知-->
    <aop:advisor advice-ref="log" pointcut-ref="pointcut"/>
    <aop:advisor advice-ref="afterLog" pointcut-ref="pointcut"/>

</aop:config>
```

#### AOP实现方式二：自定义切面

```xml
<!--    自定义类-->
<bean id="diy" class="com.f4ke.diy.DiyPointcut"/>

<aop:config>
    <!--自定义切面-->
    <aop:aspect ref="diy">
        <!--定义切入点-->
        <aop:pointcut id="pointcut" expression="execution(* com.f4ke.service.UserServiceImpl.*(..))"/>
		<!-- 通知-->
        <aop:before method="before" pointcut-ref="pointcut"/>
        <aop:after method="after" pointcut-ref="pointcut"/>
    </aop:aspect>

</aop:config>
```

#### AOP实现方式三：使用注解

```java
package com.f4ke.diy;

import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
//AnnotationPointCut就是一个切面类，个人理解
@Aspect
public class AnnotationPointCut {
    @Before("execution(* com.f4ke.service.UserServiceImpl.*(..))")
    public void before(){
        System.out.println("===============before");
    }

    @After("execution(* com.f4ke.service.UserServiceImpl.*(..))")
    public void after(){
        System.out.println("===============after");
    }
}
```

applicationContext.xml

```xml
<aop:aspectj-autoproxy/>
<bean id="annotationPointCut" class="com.f4ke.diy.AnnotationPointCut"/>
```

### 与mybatis整合



## SpringMVC

基于Java实现MVC的轻量级Web框架

### 回顾Servlet

HelloServlet

```java
package com.f4ke.servlet;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //获取前端参数
        String method = req.getParameter("method");
        if(method.equals("add")){
            req.getSession().setAttribute("msg","执行了add方法");
        }
        if(method.equals("delete")){
            req.getSession().setAttribute("msg","执行了delete方法");
        }
        //视图转发/重定向
        req.getRequestDispatcher("/WEB-INF/jsp/test.jsp").forward(req,resp);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

web.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <servlet>
        <servlet-name>hello</servlet-name>
        <servlet-class>com.f4ke.servlet.HelloServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>hello</servlet-name>
        <url-pattern>/hello</url-pattern>
    </servlet-mapping>
</web-app>
```

test.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Servlet_test</title>
</head>
<body>
${msg}
</body>
</html>
```

form.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>

<form action="/hello" method="post">
    <input type="test" name="method">
    <input type="submit">
</form>

</body>
</html>
```

### Spring原理图

![image-20200721111114020](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200721111114020.png)

使用springMVC必须配置的三大件：

**处理器映射器、处理器适配器、视图解析器**

springmvc-servlet.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--处理器映射器-->
    <bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/>
    <!--处理器适配器-->
    <bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/>
    
    <!--视图解析器:DispatcherServlet给他的ModelAndView
    1. 获取了ModelAndView的数据
    2. 解析ModelAndView视图名字
    3. 拼接视图名字，得到对应视图
    4. 将数据渲染到这个视图上
    -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" id="InternalResourceViewResolver">
        <!--前缀-->
        <property name="prefix" value="/WEB-INF/jsp/"/>
        <!--后缀-->
        <property name="suffix" value=".jsp"/>
    </bean>


    <!--Handler-->
    <bean id="/hello" class="com.f4ke.controller.HelloController"/>
</beans>
```

HelloController

```java
package com.f4ke.controller;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class HelloController implements Controller {
    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
        //ModelAndView 模型和视图
        ModelAndView mv = new ModelAndView();

        //封装对象，放在ModelAndView中。Model
        mv.addObject("msg","HelloSpringMVC!");
        //封装要跳转的视图，放在ModelAndView中
        mv.setViewName("hello"); //: /WEB-INF/jsp/hello.jsp
        return mv;
    }
}
```

hello.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>f4ke</title>
</head>
<body>
${msg}
</body>
</html>
```

### 使用注解开发SpringMVC

web.xml  DispatcherServlet配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <!--1.注册servlet-->
    <servlet>
        <servlet-name>SpringMVC</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!--通过初始化参数指定SpringMVC配置文件的位置，进行关联-->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springmvc-servlet.xml</param-value>
        </init-param>
        <!-- 启动顺序，数字越小，启动越早 -->
        <load-on-startup>1</load-on-startup>
    </servlet>

    <!--所有请求都会被springmvc拦截 -->
    <servlet-mapping>
        <servlet-name>SpringMVC</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

</web-app>
```

springmvc-servlet.xml   通常，我们只需要**手动配置视图解析器**，而**处理器映射器**和**处理器适配器**只需要开启**注解驱动**即可，而省去了大段的xml配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 -->
    <context:component-scan base-package="com.f4ke.controller"/>
    <!-- 让Spring MVC不处理静态资源 -->
    <mvc:default-servlet-handler />
    <!--
    支持mvc注解驱动
        在spring中一般采用@RequestMapping注解来完成映射关系
        要想使@RequestMapping注解生效
        必须向上下文中注册DefaultAnnotationHandlerMapping
        和一个AnnotationMethodHandlerAdapter实例
        这两个实例分别在类级别和方法级别处理。
        而annotation-driven配置帮助我们自动完成上述两个实例的注入。
     -->
    <mvc:annotation-driven />

    <!-- 视图解析器 -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"
          id="internalResourceViewResolver">
        <!-- 前缀 -->
        <property name="prefix" value="/WEB-INF/jsp/" />
        <!-- 后缀 -->
        <property name="suffix" value=".jsp" />
    </bean>

</beans>
```

HelloController 

```JAVA
package com.f4ke.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

//@Controller是为了让Spring IOC容器初始化时自动扫描到；

//@RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello；
@Controller
public class HelloController {

    @RequestMapping("/test")
    public String test(Model model){
        //向模型中添加属性msg与值，可以在JSP页面中取出并渲染
        model.addAttribute("msg","HelloSpringMVCAnnotation");
        return "test";
    }
}
```

### RestFul风格

```java
package com.f4ke.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class RestFulController {

    @RequestMapping("/add/{a}/{b}")
    //@RequestMapping(value = "/add/{a}/{b}", method = RequestMethod.DELETE)
    //@GetMapping("/add/{a}/{b}")
    public String test1(@PathVariable int a,@PathVariable int b, Model model){
        int res = a + b ;
        model.addAttribute("msg",res);
        return "test";
    }
}
```

### JSON

JSON（JavaScript Object Notation,JS对象标记），一种轻量级的数据交换格式，应用广泛

* 在前后端分离时代，json作为中间数据交换格式
* 采用独立于编程语言的纯文本格式来存储和表示数据

#### fastjson

```java
package com.kuang.controller;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.kuang.pojo.User;

import java.util.ArrayList;
import java.util.List;

public class FastJsonDemo {
   public static void main(String[] args) {
       //创建一个对象
       User user1 = new User("秦疆1号", 3, "男");
       User user2 = new User("秦疆2号", 3, "男");
       User user3 = new User("秦疆3号", 3, "男");
       User user4 = new User("秦疆4号", 3, "男");
       List<User> list = new ArrayList<User>();
       list.add(user1);
       list.add(user2);
       list.add(user3);
       list.add(user4);

       System.out.println("*******Java对象 转 JSON字符串*******");
       String str1 = JSON.toJSONString(list);
       System.out.println("JSON.toJSONString(list)==>"+str1);
       String str2 = JSON.toJSONString(user1);
       System.out.println("JSON.toJSONString(user1)==>"+str2);

       System.out.println("\n****** JSON字符串 转 Java对象*******");
       User jp_user1=JSON.parseObject(str2,User.class);
       System.out.println("JSON.parseObject(str2,User.class)==>"+jp_user1);

       System.out.println("\n****** Java对象 转 JSON对象 ******");
       JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);
       System.out.println("(JSONObject) JSON.toJSON(user2)==>"+jsonObject1.getString("name"));

       System.out.println("\n****** JSON对象 转 Java对象 ******");
       User to_java_user = JSON.toJavaObject(jsonObject1, User.class);
       System.out.println("JSON.toJavaObject(jsonObject1, User.class)==>"+to_java_user);
  }
}
```

### AJAX



























































































## SSM框架整合



# 阶段六：微服务及Linux运维

## SpringBoot



## SpringCloud



## Linux 使用

### 目录结构：

![image-20200826175828221](认识互联网.assets/image-20200826175828221.png)



> 重要目录
>
> /bin：
>
> /etc: 用来存放所有配置文件
>
> /home: 用户主目录
>
> /opt: 额外安装软件所摆放的位置
>
> /root: 该目录为系统管理员
>
> /usr: 类似于C盘中的 program files文件夹
>
> /tmp: 存放临时文件
>
> /var: 包括各种日志文件
>
> 



### 多种文件查看方式

* cat
* tac
* more
* less
* nl
* head
* tail



### 硬链接与软链接

Linux的链接分为两种：

* 硬链接：允许一个文件拥有多个路径，用户可以通过这种机制硬链接到一些重要文件上，防止误删
* 软连接：类似Windows中的创建快捷方式，如果删除源文件，快捷方式也会失效

```bash
 ⚡ root@F4ke  /home/f4ke  cat f1 
harden 9999
 ⚡ root@F4ke  /home/f4ke  ln f1 f2   # 创建硬链接
 ⚡ root@F4ke  /home/f4ke  ll 
total 8.0K
-rw-r--r-- 2 root root 12 Aug 27 14:52 f1
-rw-r--r-- 2 root root 12 Aug 27 14:52 f2
 ⚡ root@F4ke  /home/f4ke  ln -s f1 f3  # 创建软连接
 ⚡ root@F4ke  /home/f4ke  ll
total 8.0K
-rw-r--r-- 2 root root 12 Aug 27 14:52 f1
-rw-r--r-- 2 root root 12 Aug 27 14:52 f2
lrwxrwxrwx 1 root root  2 Aug 27 14:52 f3 -> f1
 ⚡ root@F4ke  /home/f4ke  cat f2
harden 9999
 ⚡ root@F4ke  /home/f4ke  cat f3
harden 9999
```

当删除发f1文件之后

```bash
 ⚡ root@F4ke  /home/f4ke  ll
total 8.0K
-rw-r--r-- 2 root root 12 Aug 27 14:52 f1
-rw-r--r-- 2 root root 12 Aug 27 14:52 f2
lrwxrwxrwx 1 root root  2 Aug 27 14:52 f3 -> f1
 ⚡ root@F4ke  /home/f4ke  rm -rf f1
 ⚡ root@F4ke  /home/f4ke  cat f2    # 硬链接还在
harden 9999
 ⚡ root@F4ke  /home/f4ke  ll  
total 4.0K
-rw-r--r-- 1 root root 12 Aug 27 14:52 f2
lrwxrwxrwx 1 root root  2 Aug 27 14:52 f3 -> f1
 ⚡ root@F4ke  /home/f4ke  cat f3  # 软链接已失效
cat: f3: No such file or directory

```

### 账号管理

#### 用户账号管理

主要涉及用户账号的添加、修改和删除

添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录shell等资源

> useradd 添加用户

```bash
 ⚡ root@F4ke  /home/f4ke  useradd -m harden  # -m 自动创建用户目录
 ⚡ root@F4ke  /home/f4ke  ls
 ⚡ root@F4ke  /home/f4ke  ls ../
f4ke  harden  ubuntu
```

> userdel 删除用户

```bash
 ⚡ root@F4ke  /home/f4ke  userdel -r harden
userdel: harden mail spool (/var/mail/harden) not found
 ⚡ root@F4ke  /home/f4ke  ls ../           
f4ke  ubuntu
 ⚡ root@F4ke  /home/f4ke  useradd -m harden
 ⚡ root@F4ke  /home/f4ke  ls ../           
f4ke  harden  ubuntu
 ⚡ root@F4ke  /home/f4ke  userdel --h      
Usage: userdel [options] LOGIN

Options:
  -f, --force                   force removal of files,
                                even if not owned by user
  -h, --help                    display this help message and exit
  -r, --remove                  remove home directory and mail spool
  -R, --root CHROOT_DIR         directory to chroot into
      --extrausers              Use the extra users database
  -Z, --selinux-user            remove any SELinux user mapping for the user
```

> usermod 修改用户

```bash
 ✘ ⚡ root@F4ke  /home/f4ke  usermod -d /home/2333 harden
 ⚡ root@F4ke  /home/f4ke  ls ../
f4ke  harden  ubuntu
 ⚡ root@F4ke  /home/f4ke  cat /etc/passwd
....
harden:x:1000:1000::/home/2333:/bin/sh
```

> 锁定账户！

```bash
 ⚡ root@F4ke  ~  passwd --h
Usage: passwd [options] [LOGIN]

Options:
  -a, --all                     report password status on all accounts
  -d, --delete                  delete the password for the named account
  -e, --expire                  force expire the password for the named account
  -h, --help                    display this help message and exit
  -k, --keep-tokens             change password only if expired
  -i, --inactive INACTIVE       set password inactive after expiration
                                to INACTIVE
  -l, --lock                    lock the password of the named account
  -n, --mindays MIN_DAYS        set minimum number of days before password
                                change to MIN_DAYS
  -q, --quiet                   quiet mode
  -r, --repository REPOSITORY   change password in REPOSITORY repository
  -R, --root CHROOT_DIR         directory to chroot into
  -S, --status                  report password status on the named account
  -u, --unlock                  unlock the password of the named account
  -w, --warndays WARN_DAYS      set expiration warning days to WARN_DAYS
  -x, --maxdays MAX_DAYS        set maximum number of days before password
                                change to MAX_DAYS

 ⚡ root@F4ke  ~  passwd -l f4ke  # 锁住无法登陆
passwd: password expiry information changed.

```

### 用户组管理

属主、属组

每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理（开发、测试、运维、root）。

用户组的管理涉及用户组的添加、删除和修改。**组的增加、删除和修改实际上就是对/etc/group文件的更新**

> 创建用户组

```bash
 ⚡ root@F4ke  /home  groupadd f4ke
 ⚡ root@F4ke  /home  cat /etc/group | grep f4ke
f4ke:x:1000:
```

> 删除用户组

```bash
 ⚡ root@F4ke  /home  groupdel f4ke
 ⚡ root@F4ke  /home  cat /etc/group | grep f4ke
 ✘ ⚡ root@F4ke  /home  

```

> 修改用户组

```bash
 ⚡ root@F4ke  /home  groupmod -g 2333 -n newf4ke f4ke  # 修改用户组id和名字
 ⚡ root@F4ke  /home  ccat /etc/group | grep newf4ke
newf4ke:x:2333:
```

> 切换用户组

```bash
✘ ⚡ root@F4ke  /home  newgrp newf4ke
```



### /etc/passwd

```bash
# 具体格式
用户名:口令:用户标识号:组标识号:注释性描述:主目录    :登录Shell
harden:x   :1000      :1000    :          :/home/2333:/bin/sh
```



### 磁盘管理

* df:列出文件系统整体的磁盘使用量

```bash
 ⚡ root@F4ke  /home  df -h  
Filesystem      Size  Used Avail Use% Mounted on
udev            886M  4.0K  886M   1% /dev
tmpfs           184M  5.9M  178M   4% /run
/dev/vda1        50G  8.5G   39G  18% /
tmpfs           917M   24K  917M   1% /dev/shm
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs           917M     0  917M   0% /sys/fs/cgroup
tmpfs           184M     0  184M   0% /run/user/500
```

* du：显示每个文件和目录的磁盘使用空间。



### 进程管理

对于开发来说，会使用Linux即可

* 每一个程序都有自己的进程，每个进程都有一个id号
* 每个进程都有一个父进程
* 进程有两种存在方式：前台/后台
* 一般情况下，服务都是在后台运行的，基本的程序是前台运行的

> 命令

PS 查看当前系统中正在执行的各种进程的信息

ps -xx ：

* -a: 显示当前终端运行的所有进程信息
* -x: 以用户的信息显示进程
* -u: 显示后台运行进程的参数



```bash
ps -aux | grep xxx  # 查看所有进程信息
ps -ef ：展示父进程信息

pstree 
	-p：显示id
	-u：显示用户组
	
	
kill -9 进程ID  #酒杀 进程
```







# 番外一：安全运维学习

## ElasticSearch



官网下载后目录

```shell
bin  启动文件
config 配置文件
	log4j2 日志配置文件
	jvm.options java虚拟机相关配置
	elasticsearch.yml elasticsearch配置文件
lib  相关的jar包 
modules 功能模块
logs  日志
plugins  插件
```



![image-20200717145139241](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200717145139241.png)



### ElasticSearch head插件

![image-20200717165217763](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200717165217763.png)

### Kibana 版本要跟 ES一致

![image-20200717171120401](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200717171120401.png)



### 安装ik分词器，下载解压至ES plugins目录下

![image-20200720115454446](认识互联网.assets/image-20200720115454446.png)

ik_max_word最小粒度划分

![image-20200720140738336](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200720140738336.png)

ik分词器可以自定义词典在配置文件中

### Rest风格

![image-20200720151034010](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200720151034010.png)



### 文档操作

```json
# 查询操作
GET index/type/id/_search


GET message/message/_search
{
   "query": { "match_all": {} }
}

GET disonline/_search
{
  "query": {
    "match_all": {}
  }
}

GET _cat/indices

# 复杂查询
# term 利用倒排索引直接查找精确值
# match 使用分词器解析，通过分析的文档进行查询
GET message/message/_search
{
   "query": {
      "bool": {
        "must": [
          {
            "match": {
              "message": "ICE"
            }
          }
        ],
        "filter": {
          "range": {
            "id": {
              "gte": 1000,
              "lte": 9000000
            }
          }
        }     
      }  
  }
}


# 验证 text 分词查询 与 keyword 精确查询
GET _cat/indices

PUT testdb1
{
  "mappings": {
    "properties": {
      "name":{
        "type": "text"
      },
      "desc":{
        "type": "keyword"
      }
    }
  }
}

PUT testdb1/_doc/1
{
  "name": "f4ke 哈登",
  "desc": "2333333 牛皮"
}


GET testdb1/_search
{
  "query": {
    "match_all": {}
  }
}

GET testdb1/_search
{
  "query": {
    "term": {
      "name": "f4ke"
    }
  }
}

GET testdb1/_search
{
  "query": {
    "term": {
      "desc": "2333333 牛皮"
    }
  }
}

DELETE testdb1
```

## Redis

#### NoSQL产生过程

* 单机MySQL时代
* memercache+MySQL（垂直拆分）
* 分库分表+水平拆分+MySQL集群
* 大数据时代数据量大且类型多变，关系型数据库力不从心

#### NoSQL特点

* 方便扩展
* 大数据量高性能
* 数据类型多样化

与传统RDBMS比较

```
传统的RDBMS
 - 结构化组织
 - SQL
 - 数据和关系都存在单独的表中
 - 数据定义语言
 
 NoSQL
 - Not Only SQL
 - 没有固定的查询语言
 - 键值对存储，列存储，图形数据库
 - 最终一致性
```

大数据时代 3V /3高

公司实践中都是关系型和非关系型共用的！

### NoSQL的四大分类

#### KV键值对：内容缓存/日志

* 新浪  Redis
* 美团  Redis+Tair
* 阿里/百度 Redis+memcache

#### 文档型数据库：

* MongoDB 
  * 基于分布式文件存储的数据库，C++编写，用来处理大量的文档

#### 列存储数据库

* HBase
* 分布式文件系统

#### 图关系数据库：社交网络

* Neo4J



### Redis特点

（Remote Dictionary Server）

* 多样化数据类型
* 持久化
* 集群
* 事务

能干吗？

* 内存存储，持久化
* 高效率，高速缓存
* 发布订阅系统
* 地图信息分析
* 计数器



### Linux安装

```bash
tar -zxvf redis-6.0.6  #解压

make #安装

make install
```

### 开启服务

```bash
 ⚡ root@F4ke  /usr/local/bin  redis-server fconfig/redis.conf 
9059:C 29 Jul 2020 11:42:52.480 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
9059:C 29 Jul 2020 11:42:52.483 # Redis version=6.0.6, bits=64, commit=00000000, modified=0, pid=9059, just started
9059:C 29 Jul 2020 11:42:52.483 # Configuration loaded

⚡ root@F4ke  /usr/local/bin  redis-cli  
127.0.0.1:6379> ping
PONG
127.0.0.1:6379> set name f4ke
OK
127.0.0.1:6379> get name
"f4ke"
127.0.0.1:6379> get name *
(error) ERR wrong number of arguments for 'get' command
127.0.0.1:6379> get  *
(nil)
127.0.0.1:6379> keys *
1) "name"
127.0.0.1:6379> shutdown
not connected> exit

```

### 性能测试

redis-benchmark 压力测试工具

### 基本命令

```shell
#数据库切换，默认16个数据库
127.0.0.1:6379> select 2
OK
127.0.0.1:6379[2]> set name f4ke
OK
127.0.0.1:6379[2]> get name
"f4ke"
127.0.0.1:6379[2]> keys *
1) "name"
127.0.0.1:6379[2]> select 1
OK
127.0.0.1:6379[1]> keys *
(empty array)
127.0.0.1:6379[1]> 
```



```shell
# 将库2的key:name转移到库0
127.0.0.1:6379> keys *
1) "name"
127.0.0.1:6379> flushdb
OK
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> select 2
OK
127.0.0.1:6379[2]> keys *
1) "name"
127.0.0.1:6379[2]> move name 0
(integer) 1
127.0.0.1:6379[2]> keys *
(empty array)
127.0.0.1:6379[2]> select 0
OK
127.0.0.1:6379> keys *
1) "name"
```

#### 计时过期

```shell
# 计时过期
127.0.0.1:6379> expire name 10
(integer) 1
127.0.0.1:6379> ttl name
(integer) 7
127.0.0.1:6379> ttl name
(integer) 6
127.0.0.1:6379> ttl name
(integer) 5
127.0.0.1:6379> expire name 10
string
```

#### 五大数据类型

##### String 操作

```shell
# String 操作
127.0.0.1:6379> flushall
OK
127.0.0.1:6379> set name f4ke  # 设置值
OK
127.0.0.1:6379> append name 13  # 追加值
(integer) 6
127.0.0.1:6379> exists name  # 判断key是否存在
(integer) 1
127.0.0.1:6379> get name
"f4ke13"
127.0.0.1:6379> strlen name  # 得到key长度
(integer) 6
127.0.0.1:6379> append key1 "2333"  # 若key不存在 append相当于set key
(integer) 4
127.0.0.1:6379> get key1
"2333"
===================================================
# 自增自减
127.0.0.1:6379> set views 0
OK
127.0.0.1:6379> incr views  # 自增
(integer) 1
127.0.0.1:6379> incrby views 10
(integer) 11
127.0.0.1:6379> decr views  # 自减
(integer) 10
127.0.0.1:6379> decrby views 10
(integer) 0
127.0.0.1:6379> 
===================================================
# 截取与替换
127.0.0.1:6379> get key1
"2333"
127.0.0.1:6379> getrange key1 0 2
"233"
127.0.0.1:6379> getrange key1 0 -1
"2333"
127.0.0.1:6379> append key1 ",bilibili"
(integer) 13
127.0.0.1:6379> get key1
"2333,bilibili"
127.0.0.1:6379> getrange key1 2 6
"33,bi"
127.0.0.1:6379> set key2 123456789
OK
127.0.0.1:6379> setrange key2 2 kk
(integer) 9
127.0.0.1:6379> get key2
"12kk56789"
===================================================
# setex set with expire 设置过期时间
# setnx set if not exist 不存在再设置
127.0.0.1:6379> setex name 100 f4ke
OK
127.0.0.1:6379> ttl name
(integer) 97
127.0.0.1:6379> setnx name harden
(integer) 0
127.0.0.1:6379> get name
"f4ke"
127.0.0.1:6379> ttl name
(integer) 78
127.0.0.1:6379> 
===================================================
# mset mget 批量设置获取
127.0.0.1:6379> mset k1 v1 k2 v2 k3 v3
OK
127.0.0.1:6379> mget k1 k2 k3
1) "v1"
2) "v2"
3) "v3"
127.0.0.1:6379> msetnx k1 vv k4 v4
(integer) 0
127.0.0.1:6379> get k1
"v1"
===================================================
# getset 若不存在值返回0，存在值返回当前值重新设置值
127.0.0.1:6379> getset k1 vv
"v1"
127.0.0.1:6379> get k1
"vv"
===================================================
```

应用场景：

* 计数器
* 统计数量  uid:3468456:follow  value 
* 粉丝数



##### List 操作

```shell
# List 操作
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> lpush list harden
(integer) 1
127.0.0.1:6379> lpush list geden
(integer) 2
127.0.0.1:6379> lpush list house
(integer) 3
127.0.0.1:6379> lrange list 0 1
1) "house"
2) "geden"
127.0.0.1:6379> lrange list 0 -1
1) "house"
2) "geden"
3) "harden"
127.0.0.1:6379> lpop list
"house"
127.0.0.1:6379> rpop list
"harden"
127.0.0.1:6379> lrange list 0 -1
1) "geden"
==================================================
# 移除指定值，包括数量
127.0.0.1:6379> lrange list 0 -1
1) "geden"
2) "geden"
3) "house"
4) "harden"
127.0.0.1:6379> Llen list
(integer) 4
127.0.0.1:6379> lrem list 1 geden
(integer) 1
127.0.0.1:6379> lrange list 0 -1
1) "geden"
2) "house"
3) "harden"
===================================================
# ltrim 通过下标截取部分元素
127.0.0.1:6379> lrange list 0 -1
1) "house"
2) "harden"
3) "geden"
127.0.0.1:6379> ltrim list 0 1
OK
127.0.0.1:6379> lrange list 0 -1
1) "house"
2) "harden"
===================================================
# rpoplpush  右边弹出，插入左边
127.0.0.1:6379> lrange list 0 -1
1) "house"
2) "gerden"
3) "harden"
127.0.0.1:6379> rpoplpush list mylist  
"harden"
127.0.0.1:6379> lrange mylist 0 -1
1) "harden"
127.0.0.1:6379> 
===================================================
# lset 根据下标将列表值更新
127.0.0.1:6379> exists list
(integer) 0
127.0.0.1:6379> lpush list harden russeel gerden house 
(integer) 4
127.0.0.1:6379> lrange list 0 -1
1) "house"
2) "gerden"
3) "russeel"
4) "harden"
127.0.0.1:6379> lset list 0 mekele
OK
127.0.0.1:6379> lrange list 0 -1
1) "mekele"
2) "gerden"
3) "russeel"
4) "harden"
===================================================
# linsert 根据列表某个元素前后进行插值
127.0.0.1:6379> lrange list 0 -1
1) "mekele"
2) "gerden"
3) "russeel"
4) "harden"
127.0.0.1:6379> linsert list before harden house
(integer) 5
127.0.0.1:6379> lrange list 0 -1
1) "mekele"
2) "gerden"
3) "russeel"
4) "house"
5) "harden"
127.0.0.1:6379> 

```

List实际上是一个链表

##### Set 操作

set集合中的值不能重复

```shell
# sadd smembers sismember 
127.0.0.1:6379> sadd set harden russel gerden house
(integer) 4
127.0.0.1:6379> smembers set
1) "house"
2) "gerden"
3) "russel"
4) "harden"
127.0.0.1:6379> sismember set harden
(integer) 1
127.0.0.1:6379> 
===================================================
#srem 移除
127.0.0.1:6379> smembers set
1) "house"
2) "gerden"
3) "russel"
4) "harden"
127.0.0.1:6379> sismember set harden
(integer) 1
127.0.0.1:6379> srem set harden
(integer) 1
127.0.0.1:6379> smembers set
1) "house"
2) "gerden"
3) "russel"
127.0.0.1:6379> 
===================================================
# sranmember 随机抽取元素
127.0.0.1:6379> smembers set
1) "house"
2) "gerden"
3) "russel"
127.0.0.1:6379> SRANDMEMBER set 
"house"
127.0.0.1:6379> SRANDMEMBER set 
"gerden"
127.0.0.1:6379> SRANDMEMBER set 
"russel"
127.0.0.1:6379> SRANDMEMBER set 2
1) "gerden"
2) "russel"
127.0.0.1:6379> SRANDMEMBER set 2
1) "house"
2) "russel"
127.0.0.1:6379> 
===================================================
# smove 移动元素
127.0.0.1:6379> SMEMBERS set
1) "gerden"
2) "house"
3) "harden" 
127.0.0.1:6379> smove set myset house
(integer) 1
127.0.0.1:6379> SMEMBERS myset
1) "house"
127.0.0.1:6379> 
===================================================
# sdiff  sinter
127.0.0.1:6379> SMEMBERS set
1) "gerden"
2) "house"
3) "harden"
127.0.0.1:6379> SMEMBERS myset
1) "house"
127.0.0.1:6379> sdiff set myset
1) "gerden"
2) "harden"
127.0.0.1:6379> sinter set myset
1) "house"
127.0.0.1:6379> 

```

##### Hash 操作

Map集合，key-map，本质跟String无太大区别

```bash
# hset/hmset/hget/hmget/hgetall/hdel
127.0.0.1:6379> hset myhash name1 f4ke
(integer) 1
127.0.0.1:6379> hget myhash name1
"f4ke"
127.0.0.1:6379> hmset myhash name1 harden name2 house
OK
127.0.0.1:6379> hmget myhash name1 name2
1) "harden"
2) "house"
127.0.0.1:6379> hgetall myhash
1) "name1"
2) "harden"
3) "name2"
4) "house"
127.0.0.1:6379> hdel myhash name2
(integer) 1
127.0.0.1:6379> hgetall myhash
1) "name1"
2) "harden"
===================================================
# hlen 获取hash的长度
# hexists 判断hash中指定字段是否存在
127.0.0.1:6379> hgetall myhash
1) "name1"
2) "harden"
127.0.0.1:6379> hlen myhash
(integer) 1
127.0.0.1:6379> hset myhash name2 house name3 russel
(integer) 2
127.0.0.1:6379> hlen myhash
(integer) 3
127.0.0.1:6379> hexists myhash name4
(integer) 0
127.0.0.1:6379> hexists myhash name3
(integer) 1

===================================================
# hkeys 获取hash所有key
# kvals 获取hash所有value
127.0.0.1:6379> hkeys myhash
1) "name1"
2) "name2"
3) "name3"
127.0.0.1:6379> hvals myhash
1) "harden"
2) "house"
3) "russel"

===================================================
# hincr 自增
127.0.0.1:6379> hincrby myhash name1 1  # 值不为整形不能加
(error) ERR hash value is not an integer
127.0.0.1:6379> hset myhash id 5
(integer) 1
127.0.0.1:6379> hget myhash id
"5"
127.0.0.1:6379> hincrby myhash id 3
(integer) 8
127.0.0.1:6379> hincrby myhash id -2
(integer) 6
127.0.0.1:6379> hsetnx myhash name2 hello  # 若字段已存在则不能设置
(integer) 0
127.0.0.1:6379> hsetnx myhash name4 hello
(integer) 1
127.0.0.1:6379> 
===================================================
```

##### Zset (有序集合)

```bash
===================================================
# zadd  
# zrangebyscore  升序
# zrevrange  降序排列
127.0.0.1:6379> zadd salary 4500 yulin 6000 f4ke 10000000 harden
(integer) 3
127.0.0.1:6379> zrange salary 0 -1 withscores
1) "yulin"
2) "4500"
3) "f4ke"
4) "6000"
5) "harden"
6) "10000000"
127.0.0.1:6379> zrangebyscore salary -inf +inf
1) "yulin"
2) "f4ke"
3) "harden"
127.0.0.1:6379> zrangebyscore salary -inf +inf withscores
1) "yulin"
2) "4500"
3) "f4ke"
4) "6000"
5) "harden"
6) "10000000"
127.0.0.1:6379> zrevrange salary 0 -1 withscores
1) "harden"
2) "10000000"
3) "f4ke"
4) "6000"
5) "yulin"
6) "4500"

===================================================
# zrem  删除
# zcard  成员数量
# zcount  区间范围的成员数量
127.0.0.1:6379> zrange salary 0 -1 withscores
1) "yulin"
2) "4500"
3) "f4ke"
4) "6000"
5) "harden"
6) "10000000"
127.0.0.1:6379> zrem salary f4ke
(integer) 1
127.0.0.1:6379> zrange salary 0 -1 withscores
1) "yulin"
2) "4500"
3) "harden"
4) "10000000"
127.0.0.1:6379> zcard salary
(integer) 2
127.0.0.1:6379> zadd salary 6000 f4ke
(integer) 1
127.0.0.1:6379> zrange salary 0 -1 withscores
1) "yulin"
2) "4500"
3) "f4ke"
4) "6000"
5) "harden"
6) "10000000"
127.0.0.1:6379> zcount salary 2000 7000
(integer) 2
===================================================
```

比set中多了排序的功能，存储班级成绩表/工资表

#### 三大特殊数据

##### geospatial

位置共享，附近的人，打车距离计算

```bash
# geoadd 添加地理位置
127.0.0.1:6379> geoadd china:city 116.40 39.90 beijing
(integer) 1
127.0.0.1:6379> geoadd china:city 121.47 31.23 shanghai 106.50 29.53 chongqing 120.16 30.24 hangzhou 108.96 34.26 xian
(integer) 4
===================================================
# geopos 获取指定字段的经纬度
127.0.0.1:6379> geopos china:city shanghai
1) 1) "121.47000163793563843"
   2) "31.22999903975783553"

===================================================
# geodist 两字段之间的距离
127.0.0.1:6379> geodist china:city shanghai beijing km
"1067.3788"
127.0.0.1:6379> geodist china:city shanghai beijing [m|km|ft|mi]
===================================================
# georadius 以指定经纬度为中心 r为半径筛选范围内的字段
127.0.0.1:6379> georadius china:city 130 40 2000 km
1) "xian"
2) "hangzhou"
3) "shanghai"
4) "beijing"
127.0.0.1:6379> georadius key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]
127.0.0.1:6379> georadius china:city 130 40 2000 km withdist 
1) 1) "xian"
   2) "1966.3189"
2) 1) "hangzhou"
   2) "1405.1329"
3) 1) "shanghai"
   2) "1242.2068"
4) 1) "beijing"
   2) "1158.5536"
127.0.0.1:6379> georadius china:city 130 40 2000 km withdist count 2
1) 1) "beijing"
   2) "1158.5536"
2) 1) "shanghai"
   2) "1242.2068"
127.0.0.1:6379> georadius china:city 130 40 2000 km withdist count 5 asc
1) 1) "beijing"
   2) "1158.5536"
2) 1) "shanghai"
   2) "1242.2068"
3) 1) "hangzhou"
   2) "1405.1329"
4) 1) "xian"
   2) "1966.3189"
127.0.0.1:6379> georadius china:city 130 40 2000 km withdist count 5 asc withcoord
1) 1) "beijing"
   2) "1158.5536"
   3) 1) "116.39999896287918091"
      2) "39.90000009167092543"
2) 1) "shanghai"
   2) "1242.2068"
   3) 1) "121.47000163793563843"
      2) "31.22999903975783553"
3) 1) "hangzhou"
   2) "1405.1329"
   3) 1) "120.1600000262260437"
      2) "30.2400003229490224"
4) 1) "xian"
   2) "1966.3189"
   3) 1) "108.96000176668167114"
      2) "34.25999964418929977"

===================================================
# georadiusbymember 根据指定成员位置设置半径进行筛选
127.0.0.1:6379> georadiusbymember china:city hangzhou 800 km withdist
1) 1) "hangzhou"
   2) "0.0000"
2) 1) "shanghai"
   2) "166.7613"
127.0.0.1:6379> georadiusbymember china:city hangzhou 2000 km withdist
1) 1) "chongqing"
   2) "1318.8910"
2) 1) "xian"
   2) "1143.6295"
3) 1) "hangzhou"
   2) "0.0000"
4) 1) "shanghai"
   2) "166.7613"
5) 1) "beijing"
   2) "1127.3378"
127.0.0.1:6379> georadiusbymember china:city hangzhou 2000 km withdist count 3 desc
1) 1) "chongqing"
   2) "1318.8910"
2) 1) "xian"
   2) "1143.6295"
3) 1) "beijing"
   2) "1127.3378"
===================================================
# 使用zrem删除成员
127.0.0.1:6379> zrange china:city 0 -1
1) "chongqing"
2) "xian"
3) "hangzhou"
4) "shanghai"
5) "beijing"
127.0.0.1:6379> zrem china:city beijing
(integer) 1
127.0.0.1:6379> zrange china:city 0 -1
1) "chongqing"
2) "xian"
3) "hangzhou"
4) "shanghai"

```

##### hyperloglog


```bash
# pfadd
# pfcount
# pfmerge
127.0.0.1:6379> PFADD mykey  1 2 3 4 5 6 8
(integer) 1
127.0.0.1:6379> PFCOUNT mykey
(integer) 7
127.0.0.1:6379> PFADD mykey1 a b j k o 0 o k
(integer) 1
127.0.0.1:6379> PFCOUNT mykey1
(integer) 6
127.0.0.1:6379> PFMERGE mykey3 mykey mykey1
OK
127.0.0.1:6379> PFCOUNT mykey3
(integer) 13
===================================================
```

##### bitmaps

位存储

统计用户信息/打卡


```bash
# setbit
# getbit
# bitcount
===================================================
```


### 事务

**Redis单条命令是原子性的，但事务不保证原子性**

Redis事务本质：一组命令的集合，一个事务中的所有命令都会被顺序化，在事务执行的时候会按照顺序执行

```bash
# 开启事务 multi
# 命令入队
# 执行事务 exec
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set name1 f4ke
QUEUED
127.0.0.1:6379> set name2 harden
QUEUED
127.0.0.1:6379> set name3 house
QUEUED
127.0.0.1:6379> exec
1) OK
2) OK
3) OK
127.0.0.1:6379> mget name1 name2 name3
1) "f4ke"
2) "harden"
3) "house"
127.0.0.1:6379> 
===================================================
# discard 弃用/取消事务
===================================================
# 编译型错误  事务中命令队列都不会被执行
# 运行时异常  非错误命令将会被执行，破坏了事务的原子性

```

#### 乐观锁

watch:在事务执行之前进行监视，若监视字段在其他线程进行修改时，当前的事务不能成功执行



### Jedis

1. 配置依赖

```xml
    <dependencies>
        <dependency>
            <groupId>redis.clients</groupId>
            <artifactId>jedis</artifactId>
            <version>3.3.0</version>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.73</version>
        </dependency>
    </dependencies>
```

2. TestPing类 测试

```java
package com.f4ke;

import redis.clients.jedis.Jedis;

public class TestPing {
    public static void main(String[] args) {
        Jedis jedis = new Jedis("127.0.0.1",6379);
        System.out.println(jedis.ping());
    }
}
```

3. 事务

```java
package com.f4ke;

import com.alibaba.fastjson.JSONObject;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.Transaction;

public class testTX {
    public static void main(String[] args) {
        Jedis jedis = new Jedis("127.0.0.1",6379);
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("name1","harden");
        jsonObject.put("name2","house");
        //开启事务
        Transaction multi = jedis.multi();
        String s = jsonObject.toJSONString();

        try {
            multi.set("user1",s);
            multi.set("user2",s);
            multi.exec();
        } catch (Exception e) {
            multi.discard();
            e.printStackTrace();
        } finally {
            System.out.println(jedis.get("user2"));
            System.out.println(jedis.get("user1"));
            jedis.close();
        }
    }
}
```

### SpringBoot整合

学习完springboot之后记录

### redis.conf

[Reids配置文件redis.conf中文详解](https://www.cnblogs.com/DreamDrive/p/5587219.html)

### redis持久化

redis为内存数据库，断电即失，所以需要持久化

#### RDB（Redis Data Base）

原理图

![image-20200806162531618](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200806162531618.png)

RDB保存的文件是dump.rdb





#### AOF(Append Only File)

aof保存的文件是appendonly.aof

![image-20200806170203140](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200806170203140.png)

### Redis发布订阅

应用场景：微信公众号，微博订阅。。。

复杂的场景会使用消息中间件 （MQ）

原理图

![image-20200806170933965](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200806170933965.png)



消息发布者：f4ke

消息订阅者：harden，house,russel

```bash
# 开启redis-server
 ⚡ root@F4ke  /usr/local/bin  redis-server fconfig/redis.conf 
15460:C 06 Aug 2020 17:17:35.680 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
15460:C 06 Aug 2020 17:17:35.680 # Redis version=6.0.6, bits=64, commit=00000000, modified=0, pid=15460, just started
15460:C 06 Aug 2020 17:17:35.680 # Configuration loaded

# 订阅频道等待消息发布
# SUBSCRIBE
 ⚡ root@F4ke  /usr/local/bin  redis-cli -p 6379
127.0.0.1:6379> ping 
PONG
127.0.0.1:6379> SUBSCRIBE f4ke
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "f4ke"
3) (integer) 1
# 此处等待接收消息
1) "message"  #消息提醒
2) "f4ke"	# 频道名字
3) "rocket champition!" #具体的消息
1) "message"
2) "f4ke"
3) "rocket NB"



# 消息发布
# PUBLISH
127.0.0.1:6379> PUBLISH f4ke "rocket champition!"
(integer) 1
127.0.0.1:6379> PUBLISH f4ke "rocket NB"
(integer) 1
127.0.0.1:6379> 
```

### Redis主从复制

指的是将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（master/leader），后者为从节点(slave/follower)。

**默认情况下，每台redis服务器都是主节点**，主机可以写，从机只能读不能写

```bash
127.0.0.1:6379> info replication
# Replication
role:master # 角色
connected_slaves:0 # 没有从机
master_replid:8665ad07898a171ea111d8ca78450b9d87886e04
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0

```



主从复制，读写分离。架构中经常使用，最低一主二从

![image-20200806173153170](认识互联网.assets/image-20200806173153170.png)

作用：

* 数据冗余
* 故障恢复
* 负载均衡
* 高可用

#### 集群环境搭建

复制三个配置文件进行修改

1、监听端口

2、pid名字

3、日志名字

4、dump.rdb 名字

```shell
# 开启三个redis服务
⚡ root@F4ke  /home/ubuntu  ps -ef | grep redis
root     19818     1  0 10:16 ?        00:00:00 redis-server 127.0.0.1:6380
root     19952     1  0 10:16 ?        00:00:00 redis-server 127.0.0.1:6381
root     20009     1  0 10:17 ?        00:00:00 redis-server 127.0.0.1:6379
root     20186 20086  0 10:17 pts/3    00:00:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox redis
```

从机设置

```bash
127.0.0.1:6380> info replication
# Replication
role:master
connected_slaves:0
master_replid:fb6946c01ce758313bb368c9359a1494006af580
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
127.0.0.1:6380> SLAVEOF 127.0.0.1 6379  # slaveof 命令
OK
127.0.0.1:6380> info replication
# Replication
role:slave # 角色转换
master_host:127.0.0.1
master_port:6379
master_link_status:up
master_last_io_seconds_ago:3
master_sync_in_progress:0
slave_repl_offset:0
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:c4803d33267c881bc137cfa155ff70d8cde1747e
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:0
127.0.0.1:6380> 
```

之后查看主机设置

```shell
127.0.0.1:6379> info replication
# Replication
role:master
connected_slaves:2  # 两个从机相关信息
slave0:ip=127.0.0.1,port=6380,state=online,offset=98,lag=0
slave1:ip=127.0.0.1,port=6381,state=online,offset=98,lag=0
master_replid:c4803d33267c881bc137cfa155ff70d8cde1747e
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:98
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:98
127.0.0.1:6379> 

```

#### 哨兵模式

主服务器宕机，需要手动把从服务器转换为主服务器，费时费力

Redis从2.8版本开始提供sentinel（哨兵模式）

![image-20200807110222068](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200807110222068.png)

测试

哨兵配置文件

```shell
# sentinel.conf
sentinel monitor mymaster 127.0.0.1 6379 1
```

开启哨兵服务

```shell
 ⚡ root@F4ke  /usr/local/bin  redis-sentinel fconfig/sentinel.conf 
28468:X 07 Aug 2020 11:20:19.999 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
28468:X 07 Aug 2020 11:20:19.999 # Redis version=6.0.6, bits=64, commit=00000000, modified=0, pid=28468, just started
28468:X 07 Aug 2020 11:20:19.999 # Configuration loaded
28468:X 07 Aug 2020 11:20:20.000 * Increased maximum number of open files to 10032 (it was originally set to 1024).
                _._                                                  
           _.-``__ ''-._                                             
      _.-``    `.  `_.  ''-._           Redis 6.0.6 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._                                   
 (    '      ,       .-`  | `,    )     Running in sentinel mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 26379
 |    `-._   `._    /     _.-'    |     PID: 28468
  `-._    `-._  `-./  _.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |           http://redis.io        
  `-._    `-._`-.__.-'_.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |                                  
  `-._    `-._`-.__.-'_.-'    _.-'                                   
      `-._    `-.__.-'    _.-'                                       
          `-._        _.-'                                           
              `-.__.-'                                               

28468:X 07 Aug 2020 11:20:20.000 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
28468:X 07 Aug 2020 11:20:20.013 # Sentinel ID is 558ccb0a5540cff64605282a552bc3a2577b5dc0
28468:X 07 Aug 2020 11:20:20.013 # +monitor master mymaster 127.0.0.1 6379 quorum 1
28468:X 07 Aug 2020 11:20:20.014 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
28468:X 07 Aug 2020 11:20:20.020 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379
```

然后将6379端口主机shutdown,哨兵日志进行选举切换主服务器

```shell
28468:X 07 Aug 2020 11:22:11.585 # +sdown master mymaster 127.0.0.1 6379
28468:X 07 Aug 2020 11:22:11.585 # +odown master mymaster 127.0.0.1 6379 #quorum 1/1
28468:X 07 Aug 2020 11:22:11.585 # +new-epoch 1
28468:X 07 Aug 2020 11:22:11.585 # +try-failover master mymaster 127.0.0.1 6379
28468:X 07 Aug 2020 11:22:11.592 # +vote-for-leader 558ccb0a5540cff64605282a552bc3a2577b5dc0 1
28468:X 07 Aug 2020 11:22:11.592 # +elected-leader master mymaster 127.0.0.1 6379
28468:X 07 Aug 2020 11:22:11.592 # +failover-state-select-slave master mymaster 127.0.0.1 6379
28468:X 07 Aug 2020 11:22:11.659 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379
28468:X 07 Aug 2020 11:22:11.659 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379
28468:X 07 Aug 2020 11:22:11.742 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379
28468:X 07 Aug 2020 11:22:12.303 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379
28468:X 07 Aug 2020 11:22:12.303 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6379
28468:X 07 Aug 2020 11:22:12.398 * +slave-reconf-sent slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
28468:X 07 Aug 2020 11:22:13.374 * +slave-reconf-inprog slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
28468:X 07 Aug 2020 11:22:13.374 * +slave-reconf-done slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
28468:X 07 Aug 2020 11:22:13.464 # +failover-end master mymaster 127.0.0.1 6379
28468:X 07 Aug 2020 11:22:13.464 # +switch-master mymaster 127.0.0.1 6379 127.0.0.1 6381
28468:X 07 Aug 2020 11:22:13.464 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381
28468:X 07 Aug 2020 11:22:13.464 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381

```

可以看到6381端口所在从服务器转换为主服务器

```shell
127.0.0.1:6381> info replication
# Replication
role:master
connected_slaves:1
slave0:ip=127.0.0.1,port=6380,state=online,offset=18713,lag=0
master_replid:5936fa8ffde1e8ee1ead65a1637a6684614c90d6
master_replid2:c4803d33267c881bc137cfa155ff70d8cde1747e
master_repl_offset:18713
second_repl_offset:9598
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:99
repl_backlog_histlen:18615
```

如果之前的主机重启了，变成从机！

```shell
127.0.0.1:6379> info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6381
master_link_status:up
master_last_io_seconds_ago:1
master_sync_in_progress:0
slave_repl_offset:25260
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:5936fa8ffde1e8ee1ead65a1637a6684614c90d6
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:25260
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:24146
repl_backlog_histlen:1115
```

> 哨兵模式配置文件

```shell
# Example sentinel.conf
 
# 哨兵sentinel实例运行的端口 默认26379
port 26379
 
# 哨兵sentinel的工作目录
dir /tmp
 
# 哨兵sentinel监控的redis主节点的 ip port 
# master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。
# quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了
# sentinel monitor <master-name> <ip> <redis-port> <quorum>
  sentinel monitor mymaster 127.0.0.1 6379 2
 
# 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码
# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码
# sentinel auth-pass <master-name> <password>
sentinel auth-pass mymaster MySUPER--secret-0123passw0rd
 
 
# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒
# sentinel down-after-milliseconds <master-name> <milliseconds>
sentinel down-after-milliseconds mymaster 30000
 
# 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，
这个数字越小，完成failover所需的时间就越长，
但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。
可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。
# sentinel parallel-syncs <master-name> <numslaves>
sentinel parallel-syncs mymaster 1
 
 
 
# 故障转移的超时时间 failover-timeout 可以用在以下这些方面： 
#1. 同一个sentinel对同一个master两次failover之间的间隔时间。
#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。
#3.当想要取消一个正在进行的failover所需要的时间。  
#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了
# 默认三分钟
# sentinel failover-timeout <master-name> <milliseconds>
sentinel failover-timeout mymaster 180000
 
# SCRIPTS EXECUTION
 
#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。
#对于脚本的运行结果有以下规则：
#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10
#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。
#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。
#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。
 
#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，
这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，
一个是事件的类型，
一个是事件的描述。
如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。
#通知脚本
# sentinel notification-script <master-name> <script-path>
  sentinel notification-script mymaster /var/redis/notify.sh
 
# 客户端重新配置主节点参数脚本
# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。
# 以下参数将会在调用脚本时传给脚本:
# <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>
# 目前<state>总是“failover”,
# <role>是“leader”或者“observer”中的一个。 
# 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的
# 这个脚本应该是通用的，能被多次调用，不是针对性的。
# sentinel client-reconfig-script <master-name> <script-path>
 sentinel client-reconfig-script mymaster /var/redis/reconfig.sh
```

### 缓存穿透和雪崩

参考[缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级](https://www.cnblogs.com/leeSmall/p/8594542.html)

#### 缓存穿透

正常情况下，我们去查询数据都是存在。

那么请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。

这种查询不存在数据的现象我们称为**缓存穿透**。

解决：

1、设置不存在的key的值为null

2、**布隆过滤器**

![image-20200807114404177](认识互联网.assets/image-20200807114404177.png)

#### 缓存击穿

在平常高并发的系统中，大量的请求同时查询一个 key 时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为**缓存击穿**。



解决：互斥锁

#### 缓存雪崩

当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上面。结果就是DB 称不住，挂掉。



## Nginx

### 1、基础概念

#### Nginx的定义

*Nginx* (engine x) 是一个高性能的[HTTP](https://baike.baidu.com/item/HTTP)和[反向代理](https://baike.baidu.com/item/反向代理/7793488)web服务器，其特点是占有内存少，[并发](https://baike.baidu.com/item/并发/11024806)能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、[京东](https://baike.baidu.com/item/京东/210931)、[新浪](https://baike.baidu.com/item/新浪/125692)、[网易](https://baike.baidu.com/item/网易/185754)、[腾讯](https://baike.baidu.com/item/腾讯/112204)、[淘宝](https://baike.baidu.com/item/淘宝/145661)等。

Nginx转为性能优化开发！

#### 反向代理

正向代理：客户端（浏览器）配置代理服务器地址进行代理

反向代理

![image-20200807150316144](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200807150316144.png)

正向代理代理客户端，反向代理代理服务器

#### 负载均衡

#### 动静分离

把动态资源和静态资源分别用不同的服务器部署

### 2、安装使用

#### Linux安装

kali2020 中自带nginx

执行目录```/usr/sbin/nginx``` 已添加进系统环境

配置文件目录```/etc/nginx/``` nginx.conf

#### 常用命令

```shell
root@kali:/etc/nginx# nginx -h
nginx version: nginx/1.16.1
Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]

Options:
  -?,-h         : this help
  -v            : show version and exit
  -V            : show version and configure options then exit
  -t            : test configuration and exit
  -T            : test configuration, dump it and exit
  -q            : suppress non-error messages during configuration testing
  -s signal     : send signal to a master process: stop, quit, reopen, reload
  -p prefix     : set prefix path (default: /usr/share/nginx/)
  -c filename   : set configuration file (default: /etc/nginx/nginx.conf)
  -g directives : set global directives out of configuration file

```





```shell
# 查看nginx服务状态
root@kali:/var/www/html# systemctl status nginx
● nginx.service - A high performance web server and a reverse proxy server
     Loaded: loaded (/lib/systemd/system/nginx.service; disabled; vendor preset: disabled)
     Active: inactive (dead)
       Docs: man:nginx(8)

Aug 09 23:38:04 kali systemd[1]: Starting A high performance web server and a reverse proxy server...
Aug 09 23:38:04 kali systemd[1]: Started A high performance web server and a reverse proxy server.
Aug 09 23:42:41 kali systemd[1]: Stopping A high performance web server and a reverse proxy server...
Aug 09 23:42:41 kali systemd[1]: nginx.service: Succeeded.
Aug 09 23:42:41 kali systemd[1]: Stopped A high performance web server and a reverse proxy server.

# 查看版本号
root@kali:/etc/nginx# nginx -v
nginx version: nginx/1.16.1

# 启动nginx
root@kali:/etc/nginx# nginx
root@kali:/etc/nginx# netstat -ano | grep 80
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      off (0.00/0/0)
tcp        0      0 192.168.118.128:80      192.168.118.1:4414      ESTABLISHED off (0.00/0/0)
tcp        0      0 192.168.118.128:80      192.168.118.1:4389      TIME_WAIT   timewait (31.54/0/0)
tcp6       0      0 :::80                   :::*                    LISTEN      off (0.00/0/0)
root@kali:/etc/nginx# ps -ef | grep nginx
root        1614       1  0 23:51 ?        00:00:00 nginx: master process nginx
www-data    1615    1614  0 23:51 ?        00:00:00 nginx: worker process
www-data    1616    1614  0 23:51 ?        00:00:00 nginx: worker process
www-data    1617    1614  0 23:51 ?        00:00:00 nginx: worker process
www-data    1618    1614  0 23:51 ?        00:00:00 nginx: worker process
root        1624    1340  0 23:52 pts/1    00:00:00 grep nginx

# 关闭nginx
root@kali:/etc/nginx# nginx -s stop
root@kali:/etc/nginx# ps -ef | grep nginx
root        1629    1340  0 23:52 pts/1    00:00:00 grep nginx

# 重载nginx （热部署）
nginx -s reload

```



#### 配置文件

```shell
# 全局块  影响服务器整体运行的配置命令
user www-data;
worker_processes auto;
pid /run/nginx.pid;
include /etc/nginx/modules-enabled/*.conf;

# events块  影响服务器与用户的网络连接
events {
	worker_connections 768;
	# multi_accept on;
}

# http块  配置最频繁的模块

http {

	##
	# Basic Settings
	##

	sendfile on;
	tcp_nopush on;
	tcp_nodelay on;
	keepalive_timeout 65;
	types_hash_max_size 2048;
	# server_tokens off;

	# server_names_hash_bucket_size 64;
	# server_name_in_redirect off;

	include /etc/nginx/mime.types;
	default_type application/octet-stream;

	##
	# SSL Settings
	##

	ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE
	ssl_prefer_server_ciphers on;

	##
	# Logging Settings
	##

	access_log /var/log/nginx/access.log;
	error_log /var/log/nginx/error.log;

	##
	# Gzip Settings
	##

	gzip on;

	# gzip_vary on;
	# gzip_proxied any;
	# gzip_comp_level 6;
	# gzip_buffers 16 8k;
	# gzip_http_version 1.1;
	# gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

	##
	# Virtual Host Configs
	##

	include /etc/nginx/conf.d/*.conf;
	include /etc/nginx/sites-enabled/*;
}


#mail {
#	# See sample authentication script at:
#	# http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript
# 
#	# auth_http localhost/auth.php;
#	# pop3_capabilities "TOP" "USER";
#	# imap_capabilities "IMAP4rev1" "UIDPLUS";
# 
#	server {
#		listen     localhost:110;
#		protocol   pop3;
#		proxy      on;
#	}
# 
#	server {
#		listen     localhost:143;
#		protocol   imap;
#		proxy      on;
#	}
#}

```



### 3、配置实例

#### 反向代理

##### 实例一：

准备工作

安装tomcat

```shell
# 使用Xftp传入kali中的 /usr/src/目录下
tar -zxvf apache-tomcat-9.0.37.tar.gz

root@kali:/usr/src# ls
apache-tomcat-9.0.37  apache-tomcat-9.0.37.tar.gz
root@kali:/usr/src# cd apache-tomcat-9.0.37/
root@kali:/usr/src/apache-tomcat-9.0.37# ls
bin  BUILDING.txt  conf  CONTRIBUTING.md  lib  LICENSE	logs  NOTICE  README.md  RELEASE-NOTES	RUNNING.txt  temp  webapps  work
root@kali:/usr/src/apache-tomcat-9.0.37# cd bin/
root@kali:/usr/src/apache-tomcat-9.0.37/bin# ls
bootstrap.jar  catalina-tasks.xml  commons-daemon.jar		 configtest.sh	digest.sh     setclasspath.bat	shutdown.sh  tomcat-juli.jar	   tool-wrapper.sh
catalina.bat   ciphers.bat	   commons-daemon-native.tar.gz  daemon.sh	makebase.bat  setclasspath.sh	startup.bat  tomcat-native.tar.gz  version.bat
catalina.sh    ciphers.sh	   configtest.bat		 digest.bat	makebase.sh   shutdown.bat	startup.sh   tool-wrapper.bat	   version.sh
root@kali:/usr/src/apache-tomcat-9.0.37/bin# ./startup.sh 
Using CATALINA_BASE:   /usr/src/apache-tomcat-9.0.37
Using CATALINA_HOME:   /usr/src/apache-tomcat-9.0.37
Using CATALINA_TMPDIR: /usr/src/apache-tomcat-9.0.37/temp
Using JRE_HOME:        /usr
Using CLASSPATH:       /usr/src/apache-tomcat-9.0.37/bin/bootstrap.jar:/usr/src/apache-tomcat-9.0.37/bin/tomcat-juli.jar
Tomcat started.	


```

反向代理原理

![image-20200810155122673](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200810155122673.png)



设置hosts

```shell
# My hosts
192.168.118.128  www.f4ke.com
```



nginx.conf设置

```shell
server {
	listen		80;
	server_name  www.f4ke.com;
	# 疑问？ 这里server_name 设置为 192.168.118.128就不能代理 解决：设置ip需访问ip才能成功代理
	
	location / {
		root	html;
		proxy_pass	http://127.0.0.1:8080;
		index index.html index.htm;
	}
}

```

设置完启动nginx，nginx成功代理tomcat

![image-20200810161907854](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200810161907854.png)

##### 实例二：

实现效果：

* nginx监听9001端口，根据访问URL的路径不同跳转到不同的端口服务



首先启动两个tomcat服务，分别在8080/8081端口

![image-20200811142219713](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200811142219713.png)

分别在创建（edu/vod）两个目录下1.html 内容为对应端口号

配置nginx.conf

```shell
        server {
                listen       9001;
                server_name  192.168.118.128;

        location ~ /edu/ {
                proxy_pass http://127.0.0.1:8080;
        }

        location ~ /vod/ { 
                proxy_pass http://127.0.0.1:8081;
        }
    }

```

然后 ```nginx -s reload``` 热部署重置nginx.conf使配置生效

![image-20200811152400599](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200811152400599.png)

![image-20200811152347321](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200811152347321.png)





#### 负载均衡

##### 实例

实现效果：

* 浏览器访问某个页面，负载均衡到两个tomcat服务中



过程：

开启两个tomcat服务分别在8080/8081端口，在其webapps目录下都新建edu目录，放入文件1.html

8080端口的1.html为 8080

8080端口的1.html为 8080



配置nginx.conf

```shell
        upstream myserver {
                server  192.168.118.128:8080;
                server  192.168.118.128:8081;
        }
        server {
                listen       80;
                server_name  192.168.118.128;

        location / {
                proxy_pass http://myserver;
        }

        #location ~ /vod/ {
        #       proxy_pass http://127.0.0.1:8081;
        #}
    }

```

访问如下页面刷新显示不同内容

![image-20200811153414960](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200811153414960.png)



##### 负载均衡原理



[nginx 负载均衡](https://www.cnblogs.com/ysocean/p/9392912.html)：好博客



#### 动静分离

![image-20200811155022823](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200811155022823.png)

### 4、nginx配置高可用集群

为了防止nginx宕机，采用keepalived进行进行监控，类似于redis中的哨兵模式

![image-20200811160640593](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200811160640593.png)

### 5、nginx原理



- Nginx由多个模块组成，每个请求的完成都是由一个或多个模块共同完成的。

- Nginx 默认采用守护模式启动，守护模式让master进程启动后在后台运行。在Nginx运行期间主要由一个master主进程和多个worker进程（数目一般与cpu数目相同）

- - master主进程主要是管理worker进程，对网络事件进行收集和分发：
    - 接收来自外界的信号
    - 向各worker进程发送信号
    - 监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程

- nginx用一个独立的worker进程来处理一个请求，一个worker进程可以处理多个请求：

- 当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接。

- 一个请求，完全由worker进程来处理，而且只在一个worker进程中处理。采用这种方式的好处：

- - 节省锁带来的开销。对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查上时，也会方便很多
  - 独立进程，减少风险。
  - 采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快重新启动新的worker进程。
  - 在一次请求里无需进程切换

![img](https://gitee.com/f4ke/MarkDownImg/raw/master/static/v2-259f991648b34db34b79aeae2c74c7a9_720w.jpg)



- sudo nginx 启动Nginx
- nginx -s stop 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。
- nginx -s quit 平稳关闭Nginx，保存相关信息，有安排的结束web服务。
- nginx -s reload 因改变了Nginx相关配置，需要重新加载配置而重载。
- nginx -s reopen 重新打开日志文件。
- nginx -c filename 为 Nginx 指定一个配置文件，来代替缺省的。
- nginx -t 不运行，而仅仅测试配置文件。Nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。
- nginx -v 显示 Nginx 的版本。
- nginx -V 显示 Nginx 的版本，编译器版本和配置参数。

-s：把信号发给Nginx的master进程

### Kubernetes 

分布式资源管理框架

# 番外二：PHP学习

## 代码审计

#### trim -> 去除首位空白符

```php
trim( string $str[, string $character_mask = " \t\n\r\0\x0B"] ) : string
```

此函数返回字符串 `str` 去除首尾空白字符后的结果。如果不指定第二个参数，**trim()** 将去除这些字符：       

- " " (ASCII *32*       (*0x20*))，普通空格符。           
- "\t" (ASCII *9*       (*0x09*))，制表符。           
- "\n" (ASCII *10*       (*0x0A*))，换行符。           
- "\r" (ASCII *13*       (*0x0D*))，回车符。           
- "\0" (ASCII *0*       (*0x00*))，空字节符。           
- "\x0B" (ASCII *11*       (*0x0B*))，垂直制表符。

#### extract -> 变量覆盖

```php
extract( array &$array[, int $flags = EXTR_OVERWRITE[, string $prefix = NULL]] ) : int
```

本函数用来将变量从数组中导入到当前的符号表中。   (数组转化为变量)

检查每个键名看是否可以作为一个合法的变量名，同时也检查和符号表中已有的变量名的冲突。

#### md5/sha1

```php
$test1 = 'QNKCDZO';
$test2 = '240610708';
$test = 's878926199a';
$test3 = 's155964671a';
$test4 = 's214587387a';
$test5 ='s214587387a';
echo md5($test);
//0e545993274517709034328855841020

sha1('aaroZmOk')  
sha1('aaK1STfY')
sha1('aaO8zKZF')
sha1('aa3OFF9m')
   
本质：NULL==FALSE==0
```

## 基础知识

### php魔术方法？

魔术方法/魔术变量都是随着不同环境可变的，跟变魔术一样

PHP 向它运行的任何脚本提供了大量的预定义常量。

不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。

有八个魔术常量它们的值随着它们在代码中的位置改变而改变。

| 变量          | 解释                                                         |
| ------------- | ------------------------------------------------------------ |
| __LINE__      | 文件中的当前行号                                             |
| __FILE__      | 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名 |
| __DIR__       | 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录 |
| __FUNCTION__  | 函数名称                                                     |
| __CLASS__     | 类的名称，本常量返回该类被定义时的名字（区分大小写）         |
| __TRAIT__     | Trait 的名字                                                 |
| __METHOD__    | 类的方法名，返回该方法被定义时的名字（区分大小写）           |
| __NAMESPACE__ | 当前命名空间的名称（区分大小写）。此常量是在编译时定义的     |

### php反序列化原理？

主观理解：**序列化是为了方便对象的传递，节省资源，把对象序列化为一个字符串进行存储，需要用到的时候再反序列化为对象，序列化和反序列化的过程中会自带很多魔术方法，当某个魔术方法被用户输入可控时，就有可能存在反序列化漏洞**

#### 常见方法

```php
__construct()         //创建对象时触发
__destruct()          //对象被销毁时触发
__wakeup()			//使用unserialize时触发，醒来
__sleep()			//使用serialize时触发，睡去
__toString()		//把类当作字符串使用时触发
__call()              //在对象上下文中调用不可访问的方法时触发
__callStatic()        //在静态上下文中调用不可访问的方法时触发
__get()               //用于从不可访问的属性读取数据
__set()               //用于将数据写入不可访问的属性
__isset()             //在不可访问的属性上调用isset()或empty()触发
__unset()             //在不可访问的属性上使用unset()时触发
__invoke()            //当脚本尝试将对象调用为函数时触发
```



测试魔术方法触发顺序

```php
<?php

class Test {
    public $name = "f4ke";
    public $passwd = "123456";

    function __construct()
    {
        echo "function __construct is running!"."<br />";
    }

    function __sleep()
    {
        echo "function __sleep is running!"."<br />";
        return array();
    }

    function __wakeup()
    {
        echo "function __wakeup is running!"."<br />";
    }

    function __destruct()
    {
        echo "function __destruct is running!"."<br />";
    }
}

$obj = new Test();
$str = serialize($obj);
$obj2 = unserialize($str);
//print_r($str);
```

![image-20200427151231763](https://i.loli.net/2020/04/28/mRv317Jqls652Zj.png)



### php文件操作

[文件包含漏洞与php伪协议](https://www.smi1e.top/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E4%B8%8Ephp%E4%BC%AA%E5%8D%8F%E8%AE%AE/)



### php表单操作

php版本特性？

php7.2中有哪些安全特性？



### php数据库操作

php代码审计 常见CMS?



# 番外三：APP渗透

# 番外四：node实现ajax

浏览器 html

```html
<!DOCTYPE html>
<html lang="en" xmlns:input="http://www.w3.org/1999/html" xmlns="">
<head>
    <meta charset="UTF-8">
    <title>test_AJAX</title>
</head>
<body>
    <input type="text" name="name" id="text">
    <input type="button" value="发送" id="btn">
</body>
<script>
    var tx = document.getElementById('text');
    tx.onblur = function () {
        var xhr = new XMLHttpRequest();
        xhr.open('get','http://127.0.0.1:8086/get');
        xhr.send();
        xhr.onreadystatechange = function () {
            if(xhr.readyState == 4){
                alert(xhr.responseText);
            }
        }
    }
</script>
</html>
```



服务端 node get.js

```js
var http = require('http');
var fs = require('fs');
var url = require('url');
var server = http.createServer();

server.listen(8086,function () {
    console.log('启动成功');
})

server.on('request', function(req,res) {
    console.log(req.url);
    var urls = url.parse(req.url, true);
    if(urls.pathname == '/get'){
        console.log('2333');
        res.end('2333');
    }else {
        fs.readFile("./1.html",function (err,data_str) {
            if(!err){
                res.end(data_str);
            }else {
                res.end('');
            }
        });
    }

})
```

# 番外五：Docker学习

## 框架图

![image-20200515151441947](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200515151441947.png)



## 常用命令

![image-20200515172827614](https://gitee.com/f4ke/MarkDownImg/raw/master/static/image-20200515172827614.png)

## 镜像（image）

```shell
# images 
⚡ root@F4ke  /  docker images -q                         
602e111c06b6
1d70b8750796
77be327e4b63
bf756fb1ae65
540a289bab6c
c489926ae4cb
ec07ee5bbb89
ea9846919a07 
# search  仓库中搜索镜像
 ⚡ root@F4ke  /  docker search nginx --filter=STARS=5000
NAME                DESCRIPTION                STARS               OFFICIAL           
nginx               Official build of Nginx.   13174               [OK] 

# pull  拉取镜像
 ⚡ root@F4ke  /  docker pull nginx 
Using default tag: latest   # 默认tag
latest: Pulling from library/nginx
54fec2fa59d0: Pull complete  	# 分层下载，docker镜像的核心
4ede6f09aefe: Pull complete 
f9dc69acb465: Pull complete 
Digest: sha256:1de8dbae66ccb87c442ac9871987b729d7eee3b5341d9db50607feeeb650631e
Status: Downloaded newer image for nginx:latest
docker.io/library/nginx:latest   # 真实下载地址

# rmi 删除镜像
 ⚡ root@F4ke  /  docker rmi 540a289bab6c 
Untagged: nginx:1
Untagged: nginx@sha256:922c815aa4df050d4df476e92daed4231f466acc8ee90e0e774951b0fd7195a4
Deleted: sha256:540a289bab6cb1bf880086a9b803cf0c4cefe38cbb5cdefa199b69614525199f
Deleted: sha256:ab18af7cee69bfb22c1771e54d5e0e68b1a1bf57bb46516142da0380b1771f4a
Deleted: sha256:02f7daf1e14541cd61a3dda1a61cc0f78fee8de2984d488b8ba5bbd3cbad9b57
Deleted: sha256:b67d19e65ef653823ed62a5835399c610a40e8205c16f839c5cc567954fcf594
```

## 容器（container）

```shell
# docker run [可选参数] image
# 参数说明
--name="Name"	容器名称
-d 				后台运行
-it			使用交互方式运行，进入容器查看内容
-p 			指定容器端口
	-p 主机端口:容器端口
	-p 容器端口
	-p ip:主机端口:容器端口
-P			随机指定端口
 ⚡ root@F4ke  /  docker run -it centos /bin/bash
[root@07b1d2c322c5 /]# 
[root@07b1d2c322c5 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@07b1d2c322c5 /]# 
[root@07b1d2c322c5 /]# exit
exit
 ⚡ root@F4ke  /  ls
apt  boot  dev  home                            initrd.img      lib    lost+found  mnt  proc  run   snap  sys  usr  vmlinuz
bin  data  etc  imgcreate_linux_install_0.1.23  initrd.img.old  lib64  media       opt  root  sbin  srv   tmp  var  vmlinuz.old

# docker [-a] ps  查看运行的容器
 ⚡ root@F4ke  /  ddocker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
5551dc9522c6        602e111c06b6        "nginx -g 'daemon of…"   30 minutes ago      Up 30 minutes       0.0.0.0:8888->80/tcp   tender_lamarr

# exit	退出后容器停止
# Ctrl + P + Q  容器不停止退出

# docker pa -a  查看所有容器状态
# rm 容器id  删除容器
 ⚡ root@F4ke  /  docker rm -f $(docker ps -aq)
5d83098e951b
26a0b31ec561
07b1d2c322c5
5551dc9522c6
251d14527383

# start/stop/restart/kill 容器操作
docker start 容器id
```

## 仓库（repository）



## 其他命令

```shell
# 查看已运行容器的docker run命令参数
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock assaflavie/runlike 容器名或ID

# docker logs  查看容器日志
# docker top 容器id 
 ✘ ⚡ root@F4ke  /  docker ps 
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS       
37980b4f0341        centos              "/bin/bash"         24 seconds ago      Up 23 seconds 
⚡ root@F4ke  /  docker top 379
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                22966               22939               0                   17:12               pts/0               00:00:00            /bin/bash
 ⚡ root@F4ke  /  

# inspect 查看容器的元数据
 ⚡ root@F4ke  /  docker inspect 379
[
    {
        "Id": "37980b4f0341f709d2a7bd22f9c1d401f22fb1df6c9964b87fa02d9518ed3bc9",
        "Created": "2020-05-15T09:12:50.436565208Z",
        "Path": "/bin/bash",
        "Args": [],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 22966,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2020-05-15T09:12:51.049137378Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:470671670cac686c7cf0081e0b37da2e9f4f768ddc5f6a26102ccd1c6954c1ee",
        "ResolvConfPath": "/var/lib/docker/containers/37980b4f0341f709d2a7bd22f9c1d401f22fb1df6c9964b87fa02d9518ed3bc9/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/37980b4f0341f709d2a7bd22f9c1d401f22fb1df6c9964b87fa02d9518ed3bc9/hostname",
        "HostsPath": "/var/lib/docker/containers/37980b4f0341f709d2a7bd22f9c1d401f22fb1df6c9964b87fa02d9518ed3bc9/hosts",
        "LogPath": "/var/lib/docker/containers/37980b4f0341f709d2a7bd22f9c1d401f22fb1df6c9964b87fa02d9518ed3bc9/37980b4f0341f709d2a7bd22f9c1d401f22fb1df6c9964b87fa02d9518ed3bc9-json.log",
        "Name": "/priceless_shannon",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "docker-default",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "default",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "CapAdd": null,
            "CapDrop": null,
            "Capabilities": null,
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "ConsoleSize": [
                0,
                0
            ],
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": [],
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "KernelMemory": 0,
            "KernelMemoryTCP": 0,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": false,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/41824e058b57fa3aa7bb65b576372dec02cf8b721f1754e9a47e8b814546da7e-init/diff:/var/lib/docker/overlay2/a5f3b907590c342c8150688057bb6b3eaad8168e252b7fd2ebc9aed7b8349747/diff",
                "MergedDir": "/var/lib/docker/overlay2/41824e058b57fa3aa7bb65b576372dec02cf8b721f1754e9a47e8b814546da7e/merged",
                "UpperDir": "/var/lib/docker/overlay2/41824e058b57fa3aa7bb65b576372dec02cf8b721f1754e9a47e8b814546da7e/diff",
                "WorkDir": "/var/lib/docker/overlay2/41824e058b57fa3aa7bb65b576372dec02cf8b721f1754e9a47e8b814546da7e/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [],
        "Config": {
            "Hostname": "37980b4f0341",
            "Domainname": "",
            "User": "",
            "AttachStdin": true,
            "AttachStdout": true,
            "AttachStderr": true,
            "Tty": true,
            "OpenStdin": true,
            "StdinOnce": true,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/bash"
            ],
            "Image": "centos",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {
                "org.label-schema.build-date": "20200114",
                "org.label-schema.license": "GPLv2",
                "org.label-schema.name": "CentOS Base Image",
                "org.label-schema.schema-version": "1.0",
                "org.label-schema.vendor": "CentOS",
                "org.opencontainers.image.created": "2020-01-14 00:00:00-08:00",
                "org.opencontainers.image.licenses": "GPL-2.0-only",
                "org.opencontainers.image.title": "CentOS Base Image",
                "org.opencontainers.image.vendor": "CentOS"
            }
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "6979dc6cc1ddf29d215035a7e823c8967575c0647cda7f7b852d90d40775c337",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {},
            "SandboxKey": "/var/run/docker/netns/6979dc6cc1dd",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "9138156fa19ae4bc21ec79ef09b80eaac0f4f7092ad4e98461a11f8f33d0e6e8",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "bf797713b694d0b668f72534a5f9f37ed858f779dbce2c904ddf644118dbef74",
                    "EndpointID": "9138156fa19ae4bc21ec79ef09b80eaac0f4f7092ad4e98461a11f8f33d0e6e8",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
                }
            }
        }
    }
]

# exec -it       进入当前正在运行的容器，开启新的终端
 ⚡ root@F4ke  /  docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS     
37980b4f0341        centos              "/bin/bash"         4 minutes ago      Up 4 minutes
 ⚡ root@F4ke  /  docker exec -it 379  /bin/bash
[root@37980b4f0341 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@37980b4f0341 /]# 
# docker attach 容器id  进入当前正在运行的容器，进入正在执行的终端

# commit  容器--> 镜像  相当于快照的镜像
 ⚡ root@F4ke  /home/ubuntu  docker commit -a="f4ke" -m="commit_test" 25c81ccbe3d9 tomcat01:1.0
sha256:1784b220d97375094d90d65c104576a25522196ded516af0da73827da4189d1f

```

## 命令小结：

docker网络

```shell
# evth-pair 成对的虚拟设备接口


? root@F4ke ? /home/ubuntu ? ip addr                                 
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 52:54:00:5a:b3:c5 brd ff:ff:ff:ff:ff:ff
    inet 172.16.16.12/20 brd 172.16.31.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::5054:ff:fe5a:b3c5/64 scope link 
       valid_lft forever preferred_lft forever
3: br-434ead42964c: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default 
    link/ether 02:42:10:6d:3a:4e brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.1/16 brd 172.18.255.255 scope global br-434ead42964c
       valid_lft forever preferred_lft forever
4: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:dc:3a:ee:6d brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
40: veth952788c@if39: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP group default 
    link/ether 1a:f7:e7:4e:9f:39 brd ff:ff:ff:ff:ff:ff link-netnsid 0
42: veth112a8bf@if41: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP group default 
    link/ether 22:e9:9f:61:1d:54 brd ff:ff:ff:ff:ff:ff link-netnsid 1
 ? root@F4ke ? /home/ubuntu ? docker exec -it tomcat01 ip addr        
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
39: eth0@if40: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
 ? root@F4ke ? /home/ubuntu ? docker exec -it tomcat02 ip addr        
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
41: eth0@if42: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever


# docker network create  自定义网络
--driver bridge 
--subnet 192.168.0.0/16 
--gateway 192.168.0.1 mynet

 ? root@F4ke ? /home/ubuntu ? docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet
eaa6d7a74275320f574543fd87de246010a11599258a2552ab11ec7689df4848
 ? root@F4ke ? /home/ubuntu ? docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
eef373b689d1        bridge              bridge              local
2dcac8768d7e        host                host                local
eaa6d7a74275        mynet               bridge              local
f0e555a1df7a        none                null                local
434ead42964c        ubuntu_default      bridge              local

# 测试自定义网络的两个tomcat容器连通性
 ✘ ⚡ root@F4ke  /home/ubuntu  docker run -d -P --name tomcat-mynet-01 --net mynet tomcat
4c121d6103ac760990a742d88dd0f12e6d542bf775de8ac44958f1654aa74ca2
 ⚡ root@F4ke  /home/ubuntu  docker run -d -P --name tomcat-mynet-02 --net mynet tomcat
7ef23af66aa7e11f60c12d77342e5b3da8558024397188427e59fef3b584ce54

 ⚡ root@F4ke  /home/ubuntu  docker exec -it tomcat-mynet-01 ping tomcat-mynet-02
PING tomcat-mynet-02 (192.168.0.3) 56(84) bytes of data.
64 bytes from tomcat-mynet-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from tomcat-mynet-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.059 ms
64 bytes from tomcat-mynet-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.074 ms
^C
--- tomcat-mynet-02 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 46ms
rtt min/avg/max/mdev = 0.059/0.069/0.074/0.007 ms

```



